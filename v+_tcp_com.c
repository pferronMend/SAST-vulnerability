     /*****************************************************************
      *                  PROPRIETARY PROGRAM MATERIAL                 *
      *                                                               *
      *   THIS MATERIAL IS PROPRIETARY TO CREDIT CARD SOFTWARE, INC.  *
      *   AND IS NOT TO BE REPRODUCED, DISCLOSED, OR USED EXCEPT IN   *
      *   ACCORDANCE WITH PROGRAM LICENSE OR OTHER WRITTEN AUTHORI-   *
      *   ZATION OF CREDIT CARD SOFTWARE INC.                         *
      *****************************************************************/
 

/*********************************************************************
* Program name.........: v+_tcp_com                                       
* Program description..: VTS Socktet PGMr for receive/send Messages   
* Language.............: C                                             
*                                                                     
* Description: This program manages the communication for FAS authorizations
*                                                                     
*                                                                     
* Function description:                                               
* This program will spawn several processes to accomplish the task of
* communicating the VAP/MIP with FAS. The first process can be called the main
* process. This process is the one started when the command to start the
* communication is executed(v+_tcp_com). This main process will spawn an inbound
* process dedicated to received incoming messages from the VAP and pass them to
* FAS. The inbound process will connect to a UNIKIX socket (UNIKIX is our CICS
* emulator for UNIX) that will start CICS transactions for every incoming
* message. The inbound process will also spawn an outbound process dedicated to
* received messages from FAS and pass them to the VAP. The outbound process will
* create a socket to listen for connections from FAS for outgoing messages.
* Once a connection is detected,  a short-life process is spawn in order to 
* handle the outgoing message.
*                                                                     
*                                                                     
* Usage:
*
*       argv[0] -h hostname -r port -t transid [-d y/n ] $FASKIXPORT
*
*       where,
*
*	-h hostname   identifies the remote host name
*       -r port       identifies the remote port number
*       -t name       identifies the transid that unikix is going to start
*       -d y or n     For debuging purposes
*       $FASKIXPORT   is received via getenv(), in here is just used for info
*
* Change Log:
*
/**********************************************************************/
/* Header files needed to perform socket API.                        */
/**********************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/timeb.h>
#include <netinet/tcp.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/msg.h>

/**********************************************************************/
/*MACROS                                                              */
/**********************************************************************/



/**********************************************************************/
#define VISA 1
#define MASTER_CARD 2

#define NOT_RETURN_ABOVE 1 
#define CHECK_PENDING -1
#define NOT_ESTABLISHED  -1

#define I_V_CONNECTED 1
#define O_V_CONNECTED 2
#define V_NOT_CONNECTED 3

#define NUMBER_OF_SESSIONS 1 /*make it > 1 if multiple_connection is TRUE*/
#define DTAQ_LEN      1024
#define PORT_LEN 8
#define VPLUS_RESP_LEN 40
#define TRANSID_LEN   4
#define MAX_PENDING_MESSAGES 20
#define MAX_MONI_MSG 10
#define TIME_WAIT_MESSAGE 5 /*QNX 4.23??? see page 11-5 (Data Message Format )*/
                            /*V.I.P specs                                     */
#define SEC_TO_WAIT_TO_CONNECT 30
#define SEC_BEFORE_CHECK 10
#define WAIT_TO_SHUTDOWN 10
#define PORT_QUEUE_KEY 0x01fa5fa5
#define WAIT_TO_CHK_VPLUS 10L

/* type of connectios for a given network (VISA, MASTER CARD)*/
#define AS_TYPE_NETWORK 0
#define ONX_SWITCH 1 /*Bancared*/
#define HYPERCOM 2

#define MINUTES 'M'
#define HOURS 'H'
#define TIME_MESUR MINUTES /*indicates if time_to_check_activity is MINUTES or HOURS */
#define MONI_REDISPLAY_MINUTE 1 /*if value is negative(-1 to -9) then redisplay will be done on ninites ending with positive value of MONI_REDISPLAY_MINUTE*/

#define LOG_ERR 1
#define NO_LOG_ERR 2
#define SET_LOG_ERR 3

#define SERVER_CONNECTION 1
#define CLIENT_CONNECTION 2

#define FUNCTION_FAILED -1
#define FUNCTION_OK_0 0
#define FUNCTION_OK_IDLE 1
#define EXIT_PROGRAM     -2

#define USER_INTERRUPT -2 
#define UNSUCCESSFULLY -1
#define SUCCESSFULLY 0

#define SHUTDOWN_REQUESTED 3
#define SESSION_SUSPENDED 2

#define INBOUND 1
#define OUTBOUND 2

#define TRUE 1
#define FALSE 0

#define PRINT_TEXT 1
#define NO_TEXT 0

#define FREE__PORT 0
#define USED_PORT 1
#define NEED_TO_FREE 2

#define DO_CLEAR 1
#define NO_CLEAR 0
 
#define FIRST_COUNT -1L

#define NOT_USED 0 /*  **  use in different conditions  **  */

/******************************************************************************/
/* Each port element on the array of avaliable ports has three sub-elements
/* They hold the port status, the PID relate to that port, and the port number
/******************************************************************************/
#define PORT_STATUS 0
#define PID_FOR_PORT 1
#define PORT_NUMBER 2


#define CON_VPLUS 1

#define ECHO_MESSAGE 1

                          
/**********************************************************************/


 typedef struct MSGHDR_t {
                            unsigned short length;
                            char reserved[2];
                          } MSGHDR_t;

  typedef struct MSGBUF {
                           long mtype;
                           char buf[PORT_LEN + 1];
                        }  MSGBUF;

/**********************************************************************/

extern char *sys_errlist[];

/************  functions that need to be declared because of visibility *****/
void exit_outbound(int , int );
void xfr_time_out();
void print_socket_error (int , char *);

static long int unikix_addr=0L;    /* 0 = This host */
static int moni_socket=NOT_ESTABLISHED; /*so no_vplus_connection can pass to exit_inbound*/
long start_time;
static int time_to_check_activity=2; /*2 should work OK since VISA sends "idle link query", This will be reset to other values depending on type_connection*/
                        /* messages every one minute                          */
static int type_session=INBOUND;
static int type_network=VISA;
static int connect_type=AS_TYPE_NETWORK;
static int ind_first = TRUE;
static int msg_seq = 99;
static long return_time;
static int year_of_time;
static int month_of_time;
static int day_of_time;
static int hour_of_time;
static int minutes_of_time;
static int seconds_of_time;
static unsigned short return_mill;
static int control_flow = TRUE; 
static debug_opt = FALSE;
static long int remote_addr;              
static int maxfd=0;
static int out_port_fd;

static int multiple_connection = FALSE; 
                                /** multiple_connection = TRUE is been thhought
                                    that will be not used, if so, then program
                                    will need to be re-tested before OKit*/
                               /** If TRUE then make NUMBER_OF_SESSIONS > 1 **/

static int limit_num_of_connection = TRUE;
static int connection_failure = FALSE; 
static int shutdown_pipe;
static int out_port_file;
static int trans_stat[NUMBER_OF_SESSIONS][3];
static int comm_timeout = FALSE;
static int       exit_timeout = FALSE;
static int child_exited = FALSE;
static char     *kix_sys; /*Pointer will be assigned by getenv*/
static char     *in_err_name="v+_comm.err.in.x";
static char     *out_err_name="v+_comm.err.out.x.xxxxx";
static char     *out_port_f_name="v+_comm.pfil.x";
static char     *run_f_name="v+_comm.runf.x";
static char     *shut_pipe_name="v+_comm.fifo.x";
static char     *moni_i_pipe_name="v+_comm.mifo.x";
static char     *moni_o_pipe_name="v+_comm.mofo.x";
static char     *moni_i_ind_name="moni_v+_comm_ind.x";
static char     *moni_o_ind_name="moni_v+_comm_ond.x";
static char     *chk_region_name="moni_v+_comm_reg.x";
static char     *capt_name="v+_comm.capt.x";
static char     line_rep_num[60];
static char *unikix_port = NULL; /* Will be set by getenv*/
static char *remote_name = NULL; /* Will point to option -h value(string)*/
static char *remote_port = NULL; /* Will point to option -r value(string)*/
static char *trans_id;           /* Will point to option -t value(string)*/
static char connect_letter;

static int moni_msg_table[MAX_MONI_MSG][3]; /* This an array to whole MAX_MONI_MSG errors or messages; each one has three elements: 1 for err/msg number, 2 is to indicate if err/msg has been display, and 3 to indicated if repeate message has been redisplayed*/

static int moni_cleared=FALSE;
static int errmxg_ind=FALSE;
static int errmxg_unikix_port;
static int remote_port_num;
static int server_port=0;
static int num_remote_port=0;
static int unix_out_port;
static int num_out_try=0;

FILE *out_err_file,*cout_err_file,*rmon_file, *chk_reg_file;

char *str_date()
{
  char *ret_date="                          ";
  struct timeb tg_mill;
  struct tm *time_parts;

  return_time=time(0L);
  ftime(&tg_mill);
  time_parts = localtime(&return_time);
  year_of_time=time_parts->tm_year;
  month_of_time=time_parts->tm_mon + 1;
  day_of_time=time_parts->tm_mday;
  hour_of_time=time_parts->tm_hour;
  minutes_of_time=time_parts->tm_min;
  seconds_of_time=time_parts->tm_sec;
  ret_date=ctime(&return_time);
  return_mill = tg_mill.millitm;
  sprintf(&ret_date[20],"%03hu",return_mill);
  ret_date[19]=':';
  ret_date[24]='\0';
  return (ret_date);
}


/**********************************************************************
 *  no_vplus_connection
 **********************************************************************/
void no_vplus_connection()
{
  alarm(0);
  if ( errno != 0 )
     if ( chk_moni(10) == TRUE )
         print_socket_error(CON_VPLUS,"Connection with VPLUS failed... ");
  if ( chk_moni(55) == TRUE )
  {
     fprintf(stderr,"<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
     fputs("!!!!!!!        No VPLUS Response (2)  !!!!!!!\n",stderr);
     fputs("!!!!!!!        No VPLUS Response (2)  !!!!!!!\n",out_err_file);
  }
  exit_inbound(55,moni_socket);
  /*comm_timeout = TRUE;*/
}
/**********************************************************************/
/**********************************************************************/


/**********************************************************************
 *  read_time_out
 **********************************************************************/
void read_time_out()
{
  comm_timeout = TRUE;
}
/**********************************************************************/
/**********************************************************************/

void print_vplus_sock_err ( char *desc_mess)
{
   
        fprintf(out_err_file,"\nUnikix error(%s(%d)); Either:\n   1) Port %d Is not open by Unikix\n   2) Transaction '%s' is not found in PCT\n   3) FAS has not been initialize(OFLC)\nor\n   4) %s Transaction failed\n",desc_mess,errno,errmxg_unikix_port,trans_id,trans_id);
    fprintf(stderr,"\nUnikix error(%s(%d)); Either:\n   1) Port %d Is not open by Unikix\n   2) Transaction '%s' is not found in PCT\n   3) FAS has not been initialize(OFLC)\nor\n   4) %s transaction failed\n",desc_mess,errno,errmxg_unikix_port,trans_id,trans_id);

}

/********************************************************************** 
 *  Print_socket_error   
 **********************************************************************/
void print_socket_error (int location, char *desc_mess )
{

   int the_errno;

   the_errno=errno;
   fprintf(stderr,"<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
      fprintf(out_err_file,"\n\n<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
   switch(the_errno)
   {
       case EACCES:
                 fprintf(out_err_file,"%s error %d: Permission to create a socket is denied\n",desc_mess,the_errno);
              fprintf(stderr,"%s error %d: Permission to create a socket is denied\n",desc_mess,the_errno);
              break;
       case ENOENT:
              if ( location == CON_VPLUS )
              {
                  print_vplus_sock_err( desc_mess);
              }
              else
              {
                 fprintf(out_err_file,"%s error %d: There was no NETWORK statement in the parmlib\n",desc_mess,the_errno);
                 fprintf(stderr,"%s error %d: There was no NETWORK statement in the parmlib\n",desc_mess,the_errno);
              }
              break;
       case EAFNOSUPPORT:
               fprintf(out_err_file,"%s error %d: The address family is not supported\n",desc_mess,the_errno);
            fprintf(stderr,"%s error %d: The address family is not supported\n",desc_mess,the_errno);
              break;
       case EINVAL:
              fprintf(out_err_file,"%s error %d: The request is invalid or not supported.  \n",desc_mess,the_errno);
            fprintf(stderr,"%s error %d: The request is invalid or not supported.  \n",desc_mess,the_errno);
              break;
       case ENOBUFS:
               fprintf(out_err_file,"%s error %d: Insufficient system resources are available\n",desc_mess,the_errno);
            fprintf(stderr,"%s error %d: Insufficient system resources are available\n",desc_mess,the_errno);
              break;
       case ECONNREFUSED:
               fprintf(out_err_file, "%s: %s errno=%d\n",desc_mess,sys_errlist[the_errno],  the_errno);
              if ( location == CON_VPLUS )
                 fprintf(out_err_file, "\n!!!! Make sure that UNIKIX is up with %s port !!!!\n\n",unikix_port);
              fprintf(stderr,"%s",desc_mess);
              perror(" ");
              if ( location == CON_VPLUS )
                  fprintf(stderr, "\n!!!! Make sure that UNIKIX is up with %s port  !!!!\n\n",unikix_port);
              break;
       case EEXIST:
          if ( location == CON_VPLUS )
          {
              print_vplus_sock_err( desc_mess);
          }
          else
          {
              puts("Socket error (possible previous error");
          }
              break;
       case EINTR:
          if ( location == CON_VPLUS )
          {
              print_vplus_sock_err( desc_mess);
          }
          else
          {
              puts("Socket error (possible previous error");
          }
              break;
       case EPROTONOSUPPORT:
               fprintf(out_err_file,"%s error %d: The protocol is not supported\n",desc_mess,the_errno);
            fprintf(stderr,"%s error %d: The protocol is not supported\n",desc_mess,the_errno);
              break;
       default:
            if ( the_errno >= ENOTSOCK && the_errno <= EINPROGRESS )
            {
               fprintf(out_err_file, "%s: %s errno=%d\n",desc_mess,sys_errlist[the_errno],  the_errno);
               fprintf(stderr,"%s",desc_mess);
               perror(" ");
            }
            else
            {
               fprintf(out_err_file,"%s: Unknown socket error %d\n",desc_mess, the_errno);
               fprintf(stderr,"%s: Unknown socket error %d\n",desc_mess, the_errno);
            }
    }
       fflush(out_err_file);

}
/**********************************************************************/
/**********************************************************************/


/**********************************************************************
 * wwrite_to_log
 *********************************************************************/
wwrite_to_log(char *session_txt, char *mxg_desc, char *mxg_value, int mxg_len, int ind_text)
{
   if ( debug_opt == TRUE )
     write_to_log(session_txt, mxg_desc, mxg_value, mxg_len, ind_text);
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 * write_to_log
 *********************************************************************/
write_to_log(char *session_txt, char *mxg_desc, char *mxg_value, int mxg_len, int ind_text)
{
   int count=0;
   int num_dsp=0;
   int loop_count;
   int grp_count;
   char neg_hex[9];
   char *dis_date;/*will get valid address from str_date()*/


   /*if (strncmp(mxg_desc,"Read following header",21) == 0)*/
   if ( debug_opt == TRUE )
   {
      dis_date=str_date();
      fprintf(out_err_file,"\n%07ld.%03hu) %s ii==ii(%s)\n",return_time - start_time,return_mill,dis_date,mxg_desc);/*if*/
      fprintf(out_err_file,"%s process: %s(%d).\n",session_txt,mxg_desc,mxg_len);
      fputs("----.---------------------------------------------------------------------------\n",out_err_file);
      fputs("    |   00  01  02  03     04  05  06  07     08  09  0A  0B     0C  0D  0E  0F\n",out_err_file);
      fputs("----|---------------------------------------------------------------------------\n",out_err_file);
      while(count<mxg_len)
      {
         num_dsp=0;
         grp_count=0;
         fprintf(out_err_file,"%03x |  ",count);
         for ( loop_count=0 ; loop_count<16; loop_count++ )
         {
            if ( count >= mxg_len )
               break;
            num_dsp++;
            if ( mxg_value[count] < 0 )
            {
               sprintf(neg_hex,"%02X",mxg_value[count]);
               neg_hex[8]='\0';
               fprintf(out_err_file,"{%2.2s}",&neg_hex[6]);
            }
            else
            {
               fprintf(out_err_file,"<%02X>",mxg_value[count]);
            }
            count++;
            if ( ++grp_count == 4 && loop_count < 12 )
            {
               fprintf(out_err_file,"   ",mxg_value[count]);
               grp_count = 0;
            }
         }
         fputs("\n",out_err_file);
         grp_count = 0;
         if ( ind_text == TRUE )
         {
            count -= num_dsp;
            fprintf(out_err_file,"    |  ",count);
            for ( loop_count=0 ; loop_count<16; loop_count++ )
            {
               if ( count >= mxg_len )
                  break;
               if ( mxg_value[count] > ' ' && mxg_value[count] < '\177' )
                  fprintf(out_err_file,"  %c ",mxg_value[count]);
               else
                  if ( mxg_value[count] == ' ' )
                     fprintf(out_err_file,"<  >");
                  else
                     fprintf(out_err_file,"    ",mxg_value[count]);
               count++;
               if ( ++grp_count == 4 && loop_count < 12 )
               {
                  fprintf(out_err_file,"   ",mxg_value[count]);
                  grp_count = 0;
               }
            }/*end for*/
            fputs("\n----|---------------------------------------------------------------------------\n",out_err_file);
         }
      }
      if ( ind_text == FALSE )
         fputs("----|---------------------------------------------------------------------------\n",out_err_file);
      fprintf(out_err_file,"\n");
   }

}
/**********************************************************************/
/**********************************************************************/


/**********************************************************************/
/*  start_listen  routine                                             */
/**********************************************************************/
int start_listen (int l_port,char *w_socket)
{
   int listen_socket;
   struct sockaddr_in listen_port;
   struct linger linger_opt;
   int option_value;
 
   listen_socket = socket(AF_INET, SOCK_STREAM, 0);
   if (listen_socket == FUNCTION_FAILED)
   {
       return FUNCTION_FAILED;
   }
 
/* ------------------------------------------------------------------*/
/* set close linger time for socket                                  */
/* ------------------------------------------------------------------*/
   linger_opt.l_onoff = 1;
   linger_opt.l_linger = 300;
 
   if (setsockopt(listen_socket, SOL_SOCKET, SO_LINGER, (char *)(&linger_opt),         sizeof(linger_opt)) == FUNCTION_FAILED
      )
   {
       if ( chk_moni(19) == TRUE )
          print_socket_error(NOT_USED,"interface_socket");
       close(listen_socket);
       return FUNCTION_FAILED;
   }
 
/* ------------------------------------------------------------------*/
/* set other socket options                                          */
/* ------------------------------------------------------------------*/
   option_value = 1;
   if (setsockopt(listen_socket, IPPROTO_TCP, TCP_NODELAY, (char *)                    (&option_value), sizeof(option_value)) == FUNCTION_FAILED
      )
   {
       if ( chk_moni(20) == TRUE )
          print_socket_error(NOT_USED,"interface_socket");
       close(listen_socket);
       return FUNCTION_FAILED;
   }
 
   option_value = 1;
   if (setsockopt(listen_socket, SOL_SOCKET, SO_REUSEADDR, (char *)                    (&option_value), sizeof(option_value)) == FUNCTION_FAILED
      )
   {
       if ( chk_moni(21) == TRUE )
          print_socket_error(NOT_USED,"interface_socket");
       close(listen_socket);
       return FUNCTION_FAILED;
   }
 
/* -------------------------------------------------------------------*/
/*  set listen port parameters                                        */
/* -------------------------------------------------------------------*/
   listen_port.sin_family        = AF_INET;
   listen_port.sin_port          = l_port;
   listen_port.sin_addr.s_addr   = INADDR_ANY; /*this host*/
   memset(listen_port.sin_zero, 0, sizeof(listen_port.sin_zero));
 
   if (bind(listen_socket, (struct sockaddr *)&listen_port, sizeof(listen_port))       == FUNCTION_FAILED
      )
   {
       if ( chk_moni(24) == TRUE )
          print_socket_error(NOT_USED,"interface_socket(bind)");
       close(listen_socket);
       return FUNCTION_FAILED;
   }
 
   if (listen(listen_socket, SOMAXCONN) == FUNCTION_FAILED)
   {
       if ( chk_moni(25) == TRUE )
          printf("Interface socket(%s socket=%d) error...\n",w_socket,listen_socket);
       close(listen_socket);
       return FUNCTION_FAILED;
   }
 
   return (listen_socket);
} /*  end start_listen routine                                         */


/************************************************************************/
/* send_message routine   - send messages to vplus or child outbound process
/************************************************************************/
int send_message(int s, void *buffer, int length)
{
   int wlength;

   while (length > 0)
   {
      if ((wlength = send(s, buffer, length, 0)) == FUNCTION_FAILED )
      {
          if ( chk_moni(26) == TRUE )
            print_socket_error(NOT_USED,"vplus_socket(send transid) failed");
            return (FUNCTION_FAILED);
      }
      if (wlength > 0)
      {
          length -= wlength;
          buffer = (char *)buffer + wlength;
      }
      else
      {
          if (wlength == 0)
             errno = ENOTCONN;/*This should not occur while writting??*/
             return (FUNCTION_FAILED);
       }
    }
    return (FUNCTION_OK_0);
}   /* end send_message routine                                         */
/**********************************************************************/
/**********************************************************************/


/**********************************************************************/
/* start xfr_message routine                                         */
/**********************************************************************/
int  xfr_message( int receive_connection, int send_connection,                  int int_socket_count, int *type_mess)
{
   MSGHDR_t header;
   char  message_read[DTAQ_LEN];  /* data que buffer to receive data */
   char  message_sent[DTAQ_LEN];  /* data que buffer to receive data */
   char session_txt[10];
   char *rconnect;
   char *wconnect;
   char *vplusname="VPlus socket";
   char request_orig;
   int  slength;
   int capt_file;
   int header_len;

   int rlength;

   if ( type_session == INBOUND )
   {
      strcpy(session_txt,"Inbound");
      rconnect=remote_name;
      wconnect=vplusname;
   }
   else
   {
      strcpy(session_txt,"Outbound");
      wconnect=remote_name;
      rconnect=vplusname;
   }
   memset(message_read, '\0', sizeof(message_read));

   comm_timeout = FALSE;
   signal(SIGALRM,xfr_time_out);
   alarm(TIME_WAIT_MESSAGE);
   if ( type_session == OUTBOUND )
   {
      if ((rlength = recv(receive_connection, &request_orig, 1, MSG_WAITALL)) != 1 )
      {
          alarm(0);
          if ( rlength == FUNCTION_FAILED )
          {
            if ( chk_moni(27) == TRUE )
              print_socket_error(NOT_USED,rconnect);
          }
            if ( chk_moni(28) == TRUE )
              fprintf(out_err_file,"\n%s process(1): Got disconnected from %s\n",session_txt,rconnect);  
          return (FUNCTION_FAILED);
      }
      if (send(int_socket_count, "|", 1,0 ) == FUNCTION_FAILED)
       if ( chk_moni(29) == TRUE )
         print_socket_error(NOT_USED,"int_socket_count: writing repose count");
      if ( debug_opt == TRUE )
      {
         if ( request_orig == 'V' )
         {
            fprintf(out_err_file,"\n ****   Response to %s request  *****\n",remote_name);
         }
         else
         {
            fputs("\n ****   Request from Vision Plus  *****\n",out_err_file);
         }
      }
   }
   header_len=sizeof(header);
   if ( type_network == MASTER_CARD) 
      header_len -= 2; 
   if ( type_network == MASTER_CARD && debug_opt == TRUE && type_session == INBOUND  && connect_type != HYPERCOM) /*MCVTSTES*/
      header_len += 2; /*MCVTSTES*/
   if ((rlength = recv(receive_connection, &header, header_len, MSG_WAITALL))
                                                   != header_len
      )
   {
          alarm(0);
          if ( rlength == FUNCTION_FAILED )
          {
            
            clear_moni(V_NOT_CONNECTED);
            if ( chk_moni(30) == TRUE )
               print_socket_error(NOT_USED,rconnect);
          }
          if ( chk_moni(31) == TRUE )
          {
             fprintf(stderr,"<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
             fprintf(stderr,"%s: Got disconnected from %s\n",session_txt,rconnect);
          }
          moni_msg_table[0][0]=9999;
          return (FUNCTION_FAILED);
   }
   if ( rlength == FUNCTION_FAILED )
   {
       if ( chk_moni(32) == TRUE )
         print_socket_error(NOT_USED,"rconnect 1");
       return (FUNCTION_FAILED);

   }
   
   if ( header.length !=  0L )
        wwrite_to_log(session_txt, "Read following header",(char *) &header,rlength,NO_TEXT); 

   if ( header.length > DTAQ_LEN )
   {
       if ( type_session == INBOUND )
       {
          if ( chk_moni(33) == TRUE )
          {
             fprintf(out_err_file,"Invalid message length (%d > %d)\n",header.length,DTAQ_LEN);
             fprintf(stderr,"Invalid message length (%d > %d)\n",header.length,DTAQ_LEN);
          }
          return (FUNCTION_FAILED);
       }
       else
          header.length=DTAQ_LEN;
   }
   if ( header.length !=  0L )
   {
      if (  connect_type == HYPERCOM && type_session == OUTBOUND )
      {
         rlength = recv(receive_connection, &message_read[5], header.length,
                          MSG_WAITALL);
         header.length += 5;
         rlength += 5;
         message_read[0] = 0x60;message_read[1] = 0x40;message_read[2] = 0x00;message_read[3] = 0x00;message_read[4] = 0x00;
      }
      else
      {
         rlength = recv(receive_connection, message_read, header.length,
                           MSG_WAITALL);
      }
      if ( rlength != header.length )
      {
             if ( rlength == FUNCTION_FAILED )
             {
               if ( chk_moni(34) == TRUE )
                 print_socket_error(NOT_USED,rconnect);
             }
             if ( chk_moni(35) == TRUE )
               fprintf(out_err_file,"\n%s process(3): Got disconnected from %s\n",session_txt,rconnect);
             return (FUNCTION_FAILED);
      }
      alarm(0);
      if ( type_network == VISA && rlength == 62 && message_read[22] == 0x08 && 
           ( message_read[23] == 0x00 || message_read[23] == 0x10 ) && 
             message_read[60] == 0x03 && message_read[61] == 0x01 )
      {
           *type_mess = ECHO_MESSAGE;
      }
      if (  connect_type == HYPERCOM && type_session == OUTBOUND )
         wwrite_to_log(session_txt, "Read following data",&message_read[5],rlength,NO_TEXT);
      else
         wwrite_to_log(session_txt, "Read following data",message_read,rlength,NO_TEXT);

      if ( type_network == MASTER_CARD && debug_opt == TRUE && type_session == INBOUND  && connect_type != HYPERCOM) /*MCVTSTES*/
          header_len -= 2; /*MCVTSTES*/
      memcpy(message_sent, &header, header_len);
      if ( type_network == MASTER_CARD && debug_opt == TRUE && type_session == OUTBOUND  && connect_type != HYPERCOM) /*MCVTSTES*/
      { /*MCVTSTES*/
          message_sent[2] = '\0'; /*MCVTSTES*/
          message_sent[3] = '\0'; /*MCVTSTES*/
          header_len += 2; /*MCVTSTES*/
      } /*MCVTSTES*/
 
      if (  connect_type == HYPERCOM && type_session == INBOUND )
      {
         rlength -= 5;
         header.length -= 5;
#if 0
==================   WHYLE RESOVING HYPERCOM PROBLEM ===========
         if ( debug_opt == TRUE )
         {
               message_sent[2]=0xf0;
               message_sent[3]=0xf1;
               memcpy(&message_sent[4], &message_read[5], rlength);
               rlength += 2;
               header.length += 2;
         }
         else

=============================================================
#endif
         memcpy(&message_sent[header_len], &message_read[5], rlength);
         memcpy(message_sent, &header, header_len);
      }
      else
      {
         memcpy(&message_sent[header_len], message_read, rlength);
      }
      slength = header_len + rlength; 
   
      if (send_message(send_connection, message_sent, slength ) == FUNCTION_FAILED )
      {
             if ( rlength == FUNCTION_FAILED )
             {
               if ( chk_moni(36) == TRUE )
                 print_socket_error(NOT_USED,wconnect);
             }
             if ( chk_moni(37) == TRUE )
               fprintf(out_err_file,"\n%s process(4): Got disconnected from %s\n",session_txt,wconnect);
             return (FUNCTION_FAILED);
      }
      write_to_log(session_txt, "Wrote following message",message_sent,slength,NO_TEXT);
      if ( type_session == INBOUND && debug_opt == TRUE )
      {
        if ( (capt_file = creat(capt_name, 0666 )) != FUNCTION_FAILED )
        {
           write(capt_file,message_sent,slength);
        }
        else
        { 
           if ( chk_moni(38) == TRUE )
              fprintf(out_err_file,"\n capt_file=%s error=%d\n",capt_name,errno);
        }
      }
   }
   else
   {
     alarm(0);
     if ( type_session == OUTBOUND )
     {
           if ( chk_moni(39) == TRUE )
           {
             fprintf(out_err_file,"\n!!!!! A Zero length message was not sent to %s  !!!!!\n",wconnect);
             printf("\n\n !!!!! A Zero length message was not sent to %s !!!!\n",wconnect);
           }
     }
     return (1);
   }

   return (FUNCTION_OK_0);

}  /* end   xfr_message routine                                      */
/**********************************************************************/
/**********************************************************************/


/********************************************************************** 
 *  Print_error   
 **********************************************************************/
void print_error (char *type_err )
{

   fprintf(out_err_file, "print_err: %s errno=%d\n",type_err, errno);
   fflush(out_err_file);
   perror(type_err);
}

/**********************************************************************
 *  xfr_time_out
 **********************************************************************/
void xfr_time_out()
{
  alarm(0);
   if ( type_session == INBOUND )
   {
      if ( chk_moni(64) == TRUE )
      {
         fprintf(stderr,"Lost connection with %s \n",remote_name);
      }
       exit_inbound(64,moni_socket);
   }
   else
   {
      if ( chk_moni(64) == TRUE )
      {
         fprintf(stderr,"Lost connection with Vision Plus \n");
      }
       exit_outbound(64,moni_socket);
   }
  /*comm_timeout = TRUE;*/
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 *  usage
 **********************************************************************/
usage(char *prog_name,int type_connection)
{
    if ( type_connection ==  SERVER_CONNECTION )
       printf("usage: %s  -h remote-hostname -t incoming-transid\n",prog_name);
    else
       printf("usage: %s  -h remote-hostname -r remote-port -t incoming-transid\n",prog_name);
    exit(UNSUCCESSFULLY);
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 *  check_childs
 *
 * This functions will check 
 * if any child process has exited, when waitpid will captured of a child
 * status and by doing it it will free PID from process table, so that
 * no zombies linger.
 **********************************************************************/
void check_childs()
{
   pid_t pid;
   pid_t thepid=-1;
   int stat;
   int count;
 
   while( (pid = waitpid(thepid, &stat, WNOHANG)) > 0)
   {
       if ( debug_opt == TRUE )
         printf("Child  process %d(%d) terminated\n",pid,stat);

   }
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 *  indound_session
 **********************************************************************/
int inbound_session( int remote_socket, int in_vplus_socket, int internal_socket,                       int int_socket_count, int shutdown_pipe
			   )
{


   fd_set read_set;
   static long last_check_time = 0L;
   long num_sec_last_check;
   int pid;
   int moni_pipe;
   int type_mess;
   int scnt;
   int when_to_check = MAX_PENDING_MESSAGES / 2;
   int max_neg_pending = -(MAX_PENDING_MESSAGES / 2);
   int max_to_check = MAX_PENDING_MESSAGES + 1;
   int ret_xfr;
   static int no_fas_resp = FALSE;
   static int no_remote_resp = FALSE;
   static int no_remote_activity = FALSE;
   static int num_mxg_pending=0;
   int num_returned;
   char outgoing_tally[MAX_PENDING_MESSAGES + 2];
   char time_mesur[8];
   char moni_str[9];
   static long count_in_messgs=0L;

   struct timeval wait_for_message;



   if (remote_socket >= maxfd)
      maxfd = remote_socket +1;

   wait_for_message.tv_sec = (long)time_to_check_activity;
   wait_for_message.tv_usec = 0L;
   if ( TIME_MESUR == MINUTES )
   {
      wait_for_message.tv_sec = (long)time_to_check_activity * 60L;
      strcpy(time_mesur,"Minutes");
   }
   else
   {
      wait_for_message.tv_sec = (long)time_to_check_activity * 60L * 60L;
      strcpy(time_mesur,"Hours");
   }


   if ((moni_pipe = open_int_proc_pipe(moni_i_pipe_name,NO_CLEAR)) == FUNCTION_FAILED)
   {
       if ( chk_moni(59) == TRUE )
          print_error("opening interprocess pipe(inbound moni)");
       return(FUNCTION_FAILED);
   }
   if (moni_pipe >= maxfd)
      maxfd = moni_pipe + 1;
   do
   {
      FD_ZERO(&read_set);
      FD_SET(internal_socket, &read_set);
      FD_SET(remote_socket, &read_set);
      FD_SET(shutdown_pipe, &read_set);
      FD_SET(moni_pipe, &read_set);

      if ((scnt = select(maxfd, &read_set, NULL, NULL, &wait_for_message)) == FUNCTION_FAILED)
      {
           if ( chk_moni(40) == TRUE )
              print_error("Inbound routine failed (select function)");
	    return(FUNCTION_FAILED);
      }

#if 0
********************************************************************************
* The following block does two things:                                       
*                                                                           
* 1) Controls when to send incomming messages base on the number of        
*    responses the inbound process is waiting to receive. (as of jun 19 1998,
*                                             This has not been implemented yet)
*    This control is optional, and it will be set if the control_flow flag is 
*    set to TRUE.
*
* 2) Warns the posibility that either the remote(e.g. VAP) or FAS is not
*    responding to the other requests.
*                                                                         
* 3) Warns if no activity is not dedected comming from remote.
*
* A tally is updated by the oubound process when ever a message is received 
* from the FAS process. This tally should balance to the count that the
* inbound process keeps when ever a message is sent to FAS. The inbound count 
* is updated when ever a maximum of pending messages is reach or a timer
* on  the  above  select  expires.  The  update  consist  of  reading  what
* ever  is  availble  at  the  tally  and  substracting  the
* number of bytes read from the inbound count. It is possible for the 
* inbound  count to become negative. This would happen if the tally is updated 
* when requests from FAS are sent and the value of counter is small enough
* that will cause it to be negative when reading tally; however, the future
* inbound response from remote should offset this. Since there are going to be 
* incoming mewssages that will not required a response from FAS, the inbound
* count is going to be increasing; thus when this counts reaches a predefine 
* posive limit number, a message will warn the opetator that there is a 
* possible problem with FAS, in the other hand if count is maximun negative
* number, then the warning will indicate that there is a posible problem with 
* the remote. These type of warning will indicate to the operator that he/she
* may want to check the status of communications, but not necessary that there
* is a problem. 
*
* When ever a warning message is display the number of messages pending is
* reset to zero.
*
* Varibles & Constants:
* --------------------
*
* num_mxg_pending:
* This variable keeps track of the number of messages that need a response. This
* number is readjusted whenever a tally is checked; the result would be equal to
* the number of messages still pending minus the number of bytes read from the 
* tally.                                          
*
* MAX_PENDING_MESSAGES is the limit that nun_mxg_peinding can reach without having
* a FAS warning message is issued.
*
* max_neg_pending is half the value of MAX_PENDING_MESSAGES, so posible not responses
* to FAS can be detected.
*
* when_to_check:
* This is one of values that tells when is time to check the tally. if the 
* value of num_mxg_pending reaches this limit, then the tally is check.
* the value of when_to_check is 1/2 of MAX_PENDING_MESSAGES
* Notice that the tally will be also checked if the select functions times out,
* and return a value of zero (scnt). 
*
*
********************************************************************************
#endif
      /*This block does not occur every time; it only goes in there is no
        incoming trafic after x time(scnt==0)  or if when_to_check is reach and pass*/
      if ( num_mxg_pending >= when_to_check || scnt == 0 )
      {
       if ( last_check_time == 0L )
       {
          last_check_time = time(0L);
       }
       num_sec_last_check = time(0L) - last_check_time;
       if ( num_sec_last_check >= (long)SEC_BEFORE_CHECK )
       {
         do
         {
            num_returned = recv(int_socket_count, outgoing_tally, max_to_check,MSG_DONTWAIT );
            if ( num_returned == FUNCTION_FAILED )
            {
               if ( errno == 11 )/*Error because there is nothing to read*/
                  num_returned = 0;
               else
               {
                  if ( chk_moni(41) == TRUE )
                     print_socket_error(NOT_USED,"recv int_socket_count");
                  break;/*to be able check internal_socket for partner exit*/
               }
            }
            if ( num_returned == 0 )
            {
               break;
#if 0
               **************************************************************
               * at this point
               * no_fas_resp does  not need to be set to TRUE because
               * this break does not means that FAS did not responsed; The
               * break could mean that either nothing was tally from outbound
               * process, or the end of reading tally queue
               **************************************************************
#endif
            }
            else
            {
               if ( no_fas_resp == TRUE )
               {
                  no_fas_resp = FALSE;
                  if ( chk_moni(42) == TRUE )
                  {
                    sprintf(line_rep_num,"echo TRY-AGAIN > v+_comm.in.count.%c",connect_letter);
                    system(line_rep_num);
                    printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
                    printf("!!!!!!   FAS ACTIVITY IS NOW BEEN DECTECTED    !!!!!!\n");
                  }
               }
            }

            num_mxg_pending -= num_returned;
            if ( control_flow == FALSE )
              break;
         }while (num_mxg_pending >= when_to_check);
         /****alarm(0);****/
         if ( num_mxg_pending < max_neg_pending ) 
         {
            no_remote_resp = TRUE;
            if ( chk_moni(45) == TRUE )
            {
               printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
               printf("!!! WARNING: IT SEEMS THAT %s IS NOT RESPONDING TO FAS REQUESTS  !!!!\n",remote_name);
            }
            num_mxg_pending=0;
         }
         if ( num_mxg_pending > MAX_PENDING_MESSAGES )
         {
            no_fas_resp = TRUE;
            if ( chk_moni(46) == TRUE )
            {
               printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
               printf("!!! WARNING: IT SEEMS THAT FAS IS NOT RESPONDING TO %s REQUESTS  !!!!\n",remote_name);
            }
            num_mxg_pending=0;
         }
         if ( scnt == 0 )
         {
            no_remote_activity = TRUE;
            errmxg_ind=TRUE;
            errmxg_ind=TRUE;
            if ( chk_moni(47) == TRUE )
             {
               printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
               printf("!!! WARNING: %s IS BEEN QUIET FOR MORE THAN %d %s !!!!\n",remote_name,time_to_check_activity,time_mesur);
            }
         }
         last_check_time = time(0L);
       }/* i f  num_sec_last_check >= SEC_BEFORE_CHECK */
      }
      if ((scnt > 0) && FD_ISSET(remote_socket, &read_set))
      {
	 scnt --;
         if ( no_remote_resp == TRUE )
            no_remote_resp = FALSE;
         if ( no_remote_activity == TRUE )
         {
           if ( chk_moni(48) == TRUE )
           {
            sprintf(line_rep_num,"echo TRY-AGAIN > v+_comm.in.count.%c",connect_letter);
            system(line_rep_num);
            printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
            printf("!!!!!!   REMOTE ACTIVITY IS NOW BEEN DECTECTED    !!!!!!\n");
           }
            no_remote_activity = FALSE;
            errmxg_ind=FALSE;
         }
         type_mess=NOT_USED;
	 if ((ret_xfr =  xfr_message ( remote_socket, in_vplus_socket, int_socket_count,&type_mess)) == FUNCTION_FAILED)
         {
             /*continue;*/
	     return(FUNCTION_FAILED);
         }
         if ( moni_cleared == FALSE )
           clear_moni(I_V_CONNECTED);
         if (ret_xfr == FUNCTION_OK_0)
         {
              if ( type_mess != ECHO_MESSAGE )
                 count_in_messgs++;
            if ( debug_opt == TRUE )
              fprintf(stderr,"I");
            num_mxg_pending++;
            /***continue****/; /*use continue if Vplus stays conencted in a loop*/
            return(FUNCTION_OK_0);/* To restart FAS TRANSACTION from next incomming */
         }
         else
         {
            if ( debug_opt == TRUE )
               fprintf(stderr,"L");
         }
      }
 
      if ((scnt > 0) && FD_ISSET(shutdown_pipe, &read_set))
      {
	 return(SHUTDOWN_REQUESTED);
      }
#if 0
--------------------------  remarked because it did not detect disconnection ---
      FD_SET(in_vplus_socket, &read_set); this one will go before select
      if ((scnt > 0) && FD_ISSET(in_vplus_socket, &read_set))
      {
	 scnt --;
         /*MSG_PEEK | MSG_DONTWAIT is set so process reading response from VPLUS is not affected*/
         if ( (recv(in_vplus_socket, moni_str, 1,MSG_PEEK | MSG_DONTWAIT )) == FUNCTION_FAILED )
         {
            if ( chk_moni(61) == TRUE )
              puts("Connection with VPLUS/UNIKIX was lost");
             continue; /*still connected to Vision Plus*/
            /*return (FUNCTION_FAILED);*/
         }
      }
-----------------------------------------------------------------------------
#endif
      if ((scnt > 0) && FD_ISSET(moni_pipe, &read_set))
      {
	 scnt --;
         read(moni_pipe,moni_str,8);
         if ( strncmp(moni_str,"recon_v+",8) == 0 )
         {
              ind_first = TRUE;
         }
         else
         {
           if ( errmxg_ind == FALSE)
           {
              if ( ( pid = fork() ) == 0 )
              {
                if ( debug_opt != TRUE )
                   signal(SIGINT, SIG_IGN);
                sprintf(line_rep_num,"echo %010ld > v+_comm.in.count.%c",count_in_messgs,connect_letter);
                system(line_rep_num);
                exit_inbound_mxg(SUCCESSFULLY);
              }/*end fork*/
              check_childs();
           }
           if ( strncmp(moni_str,"monitor ",8) != 0 )
             if (clear_pipe(moni_pipe) == FUNCTION_FAILED )
              return (FUNCTION_FAILED);
         }
         unlink(moni_i_ind_name);
      }
      if ((scnt > 0) && FD_ISSET(internal_socket, &read_set))
      {
	 return(SESSION_SUSPENDED);
      }
 
    } while(NOT_RETURN_ABOVE);   
    /*Program does not need to break out of the above loop*/


}
/**********************************************************************
 *  free_port
 **********************************************************************/
void free_port(int port_inx)
{
   int r_stat;
   int count;
   int rwrite_flg;
   int first_read = TRUE;
   int first_loop = TRUE;
   int r_port,f_port;
   struct MSGBUF r_buff;

   do
   {
     comm_timeout = FALSE;
     signal(SIGALRM,read_time_out);
     rwrite_flg=TRUE;
     if ((msgrcv(out_port_fd,&r_buff,PORT_LEN,1,IPC_NOWAIT)) != PORT_LEN )
     {
               
       if ( port_inx != CHECK_PENDING )/*if no ports available in list*/
       {
          trans_stat[port_inx][PORT_STATUS] = NEED_TO_FREE;
          trans_stat[port_inx][PID_FOR_PORT] = 0;
       }
       return;
     }
     alarm(0);
     r_buff.buf[PORT_LEN]='\0';
     r_port=atoi(r_buff.buf);
     if ( port_inx != CHECK_PENDING )
     {
        if ( r_port == trans_stat[port_inx][PORT_NUMBER] )
        {
          trans_stat[port_inx][PORT_STATUS] = FREE__PORT;
          trans_stat[port_inx][PORT_NUMBER] = 0;
          trans_stat[port_inx][PID_FOR_PORT] = 0;
          fprintf(out_err_file,"port %d is now free\n",r_port);
          return;
        }
     }
     else
     {
        for (count=0 ; count < NUMBER_OF_SESSIONS ; count++)
        {
          if ( r_port == trans_stat[count][PORT_NUMBER] &&                                     trans_stat[port_inx][PORT_STATUS] == NEED_TO_FREE
          )
          {
             trans_stat[count][PORT_STATUS] = FREE__PORT;
             trans_stat[count][PORT_NUMBER] = 0;
             trans_stat[port_inx][PID_FOR_PORT] = 0;
             fprintf(out_err_file,"port %d is now free\n");
             rwrite_flg=FALSE;
          }
       }
     }
     if ( rwrite_flg == TRUE )
     {
       r_buff.mtype=1;
       if (msgsnd(out_port_fd,&r_buff,PORT_LEN,IPC_NOWAIT) != FUNCTION_OK_0)
       {
          printf("XXXXX: %d was not written to FAS port list\n",r_port);
          printf("Notes:\n");
          printf("       - FAS port list is only used by transactions generated from FAS\n");
          printf("       - If port %d still available, then FAS will use it even if is not on this list ",server_port + 1);
       }
     }
     if ( first_read == TRUE )
     {
        first_read = FALSE;
        f_port = r_port;
        continue;
     }
     else
     {
        first_loop = FALSE;
     }
   }while (f_port != r_port || first_loop == TRUE );
}
/**********************************************************************/
/**********************************************************************/

exit_init(int type_exit)
{
      exit(type_exit);
}
/**********************************************************************/
/**********************************************************************/

exit_main(int type_exit)
{
      if ( debug_opt == TRUE )
         puts("::::::    MAIN PROCESS EXITED    ::::::");
      unlink(run_f_name);
      exit(type_exit);
}
/**********************************************************************/
/**********************************************************************/

exit_inbound(int type_exit, int rmoni_socket)
{
   int count;
   char moni_line[10];

      if ( rmoni_socket != 0 )
      {
         for ( count=0 ; count<MAX_MONI_MSG ; count++ )
         {
            sprintf(moni_line,"%04d",moni_msg_table[count][0]);
            moni_line[4]='\0';
            send(rmoni_socket, moni_line, 5,0 );
            sprintf(moni_line,"%08d",moni_msg_table[count][1]);
            moni_line[8]='\0';
            send(rmoni_socket, moni_line, 9,0 );
            sprintf(moni_line,"%01d",moni_msg_table[count][0]);
            moni_line[1]='\0';
            send(rmoni_socket, moni_line, 2,0 );
         }
      }

      close(rmoni_socket);
      if ( debug_opt == TRUE )
         puts("::::::    INBOUND PROCESS EXITED    ::::::");
      exit(type_exit);
}
/**********************************************************************/
/**********************************************************************/

exit_chk_vplus(int type_exit)
{
      exit(type_exit);
}
/**********************************************************************/
/**********************************************************************/

void exit_outbound(int type_exit, int rmoni_socket)
{
   int count;
   char moni_line[10];

      if ( rmoni_socket != 0 )
      {
         for ( count=0 ; count<MAX_MONI_MSG ; count++ )
         {
            sprintf(moni_line,"%04d",moni_msg_table[count][0]);
            moni_line[4]='\0';
            send(rmoni_socket, moni_line, 5,0 );
            sprintf(moni_line,"%08d",moni_msg_table[count][1]);
            moni_line[8]='\0';
            send(rmoni_socket, moni_line, 9,0 );
            sprintf(moni_line,"%01d",moni_msg_table[count][0]);
            moni_line[1]='\0';
            send(rmoni_socket, moni_line, 2,0 );
         }
      }

      close(rmoni_socket);

      if ( debug_opt == TRUE )
         puts("::::::    OUTBOUND PROCESS EXITED    ::::::");
      exit(type_exit);
}
/**********************************************************************/
/**********************************************************************/
exit_inbound_mxg(int type_exit)
{
      exit(type_exit);
}

/**********************************************************************/
/**********************************************************************/

exit_outbound_mxg(int type_exit)
{
      exit(type_exit);
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 *  sig_main_int if interrupt key is hit for main process.
 **********************************************************************/
void sig_main_int(int signo)
{
      unlink(run_f_name);
      unlink(out_port_f_name);
      exit(USER_INTERRUPT);
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 *  sig_inbound_int if interrupt key is hit.
 **********************************************************************/
void sig_inbound_int(int signo)
{
      if ( multiple_connection == FALSE )
          unlink(out_port_f_name);
      exit(USER_INTERRUPT);
}
/**********************************************************************/
/**********************************************************************/


/**********************************************************************
 *  sig_inbound_exited
 **********************************************************************/
void sig_inbound_exited(int signo)
{
   pid_t pid;
   int stat;
   int count;
 
   while( (pid = waitpid(-1, &stat, WNOHANG)) > 0)
   {
     if ( debug_opt == TRUE )
         fprintf(out_err_file,"Inbound process %d terminated\n",pid);

     if ( multiple_connection == FALSE )
     {
         if ( trans_stat[0][PID_FOR_PORT] == pid )
           free_port(0);
         unlink(out_port_f_name);
     }
     else
     {
       for ( count=0 ; count<NUMBER_OF_SESSIONS ; count++)
       {
         if ( trans_stat[count][PID_FOR_PORT] == pid )
         {
            free_port(count);
         }
         else
         {
            if ( trans_stat[count][PORT_STATUS] == NEED_TO_FREE )
            {
              free_port(count);
            }
         }
       }
     }
   }
   child_exited = TRUE;
   return;
}
/**********************************************************************/
/**********************************************************************/

#if 0
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/**********************************************************************
 *  sig_outbound_exited
 **********************************************************************/
void sig_outbound_exited(int signo)
{
   pid_t pid;
   int stat;

   pid = waitpid(-1, &stat, WNOHANG);
   if ( debug_opt == TRUE )
       fprintf(out_err_file,"Process %d terminated\n",pid);
   if ( multiple_connection == FALSE )
      creat(out_port_f_name, 0666 );/*clear file*/
}
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#endif 


/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 *  outbound_session
 **********************************************************************/
int outbound_session(int remote_socket, int internal_socket, int int_socket_count)
{
	   
   fd_set read_set;
   int scnt;
   int type_mess;
   int moni_pipe;
   long count_out_messgs=0L;
   pid_t pid;
   int stat;
   int errflg = 0;
   int listen_vplus_socket;
   int out_vplus_socket;
   int length = 0;
   

   MSGHDR_t header;
   char  message_buffer[DTAQ_LEN];  /* data que buffer to receive data */

   if (!(out_err_file = fopen(out_err_name,"a")))
   {
      out_err_file=stderr;
   }
   else
   {
      setbuf(out_err_file,NULL);
   }
   fprintf(out_err_file,"%s\n",str_date());
   fprintf(out_err_file,"File opened by PID %d port=%d\n",getpid(),unix_out_port);
   clear_moni(O_V_CONNECTED);

   if ((listen_vplus_socket = start_listen(unix_out_port, "VPLUS")) == FUNCTION_FAILED)
   {
       if ( chk_moni(49) == TRUE )
          print_socket_error(NOT_USED,"listen_Vplus_socket() failed");
       if ( out_err_file != stderr )
           close(out_err_file);
       return(FUNCTION_FAILED);
   }
   if (listen_vplus_socket >= maxfd)
       maxfd = listen_vplus_socket + 1;

   if ((moni_pipe = open_int_proc_pipe(moni_o_pipe_name,NO_CLEAR)) == FUNCTION_FAILED)
   {
       if ( chk_moni(60) == TRUE )
          print_error("opening interprocess pipe(outbound moni)");
       return(FUNCTION_FAILED);
   }
   if (moni_pipe >= maxfd)
      maxfd = moni_pipe + 1;

   for(;;)
   {
      FD_ZERO(&read_set);
      FD_SET(internal_socket, &read_set);
      FD_SET(listen_vplus_socket, &read_set);
      FD_SET(moni_pipe, &read_set);

      length = 0;
      if ((scnt = select(maxfd, &read_set, NULL, NULL, NULL)) == FUNCTION_FAILED)
      {
           if ( chk_moni(50) == TRUE )
              print_error("listen_vplus_socket(select) failed");
	    return(FUNCTION_FAILED);
      }
      if ((scnt > 0) && FD_ISSET(listen_vplus_socket, &read_set))
      {
         scnt--;
         if ((out_vplus_socket = accept(listen_vplus_socket, NULL, &length)) == FUNCTION_FAILED)
   
         {
           if ( chk_moni(51) == TRUE )
               print_socket_error(NOT_USED,"out_vplu_socket(accept) failed");
	    return(FUNCTION_FAILED);
         }
         if (out_vplus_socket >= maxfd)
              maxfd = out_vplus_socket + 1;

            FD_ZERO(&read_set);
            FD_SET(out_vplus_socket, &read_set);
      
            comm_timeout = FALSE;
            signal(SIGALRM,read_time_out);
            alarm(3);
            if ((scnt = select(maxfd, &read_set, NULL, NULL, NULL)) == FUNCTION_FAILED)
            {
               alarm(0);
               if ( chk_moni(52) == TRUE )
               {
                 if ( comm_timeout == TRUE)
                 {
#if 0
*****************************************************************************
* The following error will mean that FAS connected to outbound process
* But nothing was sent to it.
*****************************************************************************
#endif
                    fputs("out_vplu_socket(select timeout)\n",out_err_file);
                    puts("out_vplu_socket(select timeout) ");
                 }
                 else
                    print_error("out_vplu_socket(select) failed");
               }
               exit_outbound(52,moni_socket);
               /*exit_outbound_mxg(52);*/
            }
            alarm(0);
            if ((scnt > 0) && FD_ISSET(out_vplus_socket, &read_set))
            {
	       scnt --;
               type_mess=NOT_USED;
	       if ((xfr_message (out_vplus_socket, remote_socket, int_socket_count,&type_mess)) == FUNCTION_FAILED)
	       {
                   if ( out_err_file != stderr )
                      close(out_err_file);
                   if ( chk_moni(53) == TRUE )
                       puts("outbound xfr failed  ... \n");
                   exit_outbound(53,moni_socket); 
                   /*exit_outbound_mxg(53); */
	       }
              if ( type_mess != ECHO_MESSAGE )
                 count_out_messgs++;
                if ( debug_opt == TRUE )
                   fprintf(stderr,"O");
         }/*end_if_scnt*/
      }
      if ((scnt > 0) && FD_ISSET(internal_socket, &read_set))
      {
         /*fputs("Outbound session has been suspended(2)\n",out_err_file);*/
         if ( out_err_file != stderr )
             close(out_err_file);
         close(listen_vplus_socket);
	 return(SESSION_SUSPENDED);
      }
      if ((scnt > 0) && FD_ISSET(moni_pipe, &read_set))
      {
	 scnt --;
         if ( ( pid = fork() ) == 0 )
         {
             if ( debug_opt != TRUE )
               signal(SIGINT, SIG_IGN);
             sprintf(line_rep_num,"echo %010ld > v+_comm.out.count.%c",count_out_messgs,connect_letter);
             system(line_rep_num);
             exit_outbound_mxg(SUCCESSFULLY);
 
         }/*end fork*/
         check_childs();
         if (clear_pipe(moni_pipe) == FUNCTION_FAILED )
             return (FUNCTION_FAILED);
        unlink(moni_o_ind_name);
      }
      close(out_vplus_socket);
   } /* end for loop  listen_vplus_socket                        */

   /*Above loop is only break by returns return(SESSION_SUSPENDED);*/
}
/**********************************************************************/
/**********************************************************************/


/**********************************************************************
 *  connect_to_vplus
 **********************************************************************/
connect_to_vplus(char *ctrans_id )
{
   struct sockaddr_in unikix_sock_add;

   static long cnt_sec_chk_vplus=FIRST_COUNT;
   int c_vplus_socket;
   int length;
   int len_reg;
   int pid;
   int start_region=0;
   int count;
   int ind_no_reg=TRUE;

   char vplus_mxg_buf[VPLUS_RESP_LEN + 1];
   char *region_name;  /*Pointer set by getenv()*/
   char reg_id[20];
   char reg_line[20];

   if ( msg_seq == 99 )
     msg_seq = 0;
   else
     msg_seq++;
   if ( ind_first == TRUE )
   {
     str_date();
     sprintf(reg_id,"%04d%02d%02d%02d%02d%02d%03hu\n",year_of_time,
             month_of_time,day_of_time, hour_of_time,minutes_of_time,
             seconds_of_time,return_mill);
     reg_id[17]='\0';
     /*****************************************************************/
     /***   PORT_LEN is 8 if increase then need consider increasing ****
     /***    |       the length of message to unikix                ***/
     /***    ------------------------------------------------       ***/
     /***                                                    |      ***/
     sprintf(vplus_mxg_buf,"xxxx,%02d: %0*d%IOP%s%c \n", msg_seq,8,unix_out_port,reg_id,connect_letter);
   }
   else
   {
     str_date();
     /******************  cnt_sec_chk_vplus will be reset later in code ******/
     if ( return_time > ( cnt_sec_chk_vplus + WAIT_TO_CHK_VPLUS ) || cnt_sec_chk_vplus == FIRST_COUNT )
     {
       sprintf(vplus_mxg_buf,"xxxx,%02d: %0*d%IOPRESP               \n",msg_seq,8,unix_out_port);
     }
     else
     {
       sprintf(vplus_mxg_buf,"xxxx,%02d: %0*d%IOPNOID               \n",msg_seq,8,unix_out_port);
     }
   }

   strncpy(vplus_mxg_buf,ctrans_id,TRANSID_LEN);
   c_vplus_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (c_vplus_socket < 0)
   {
       if ( chk_moni(23) == TRUE )
          print_socket_error(NOT_USED,"c_vplus_socket");
       return(FUNCTION_FAILED);
   }

   memset(&unikix_sock_add, 0, sizeof(struct sockaddr_in));
   unikix_sock_add.sin_family=AF_INET;
   unikix_sock_add.sin_addr.s_addr = unikix_addr;
   unikix_sock_add.sin_port=htons(atoi(unikix_port));
   errmxg_unikix_port=unikix_sock_add.sin_port;
   /*printf("sock:family %d(%x) port %d(%x) host addr %d.%d.%d.%d(%d(%x) + (%d(%x))) : socket port %d len struc=%d(%x)\n",
        unikix_sock_add.sin_family,
        unikix_sock_add.sin_family,
        unikix_sock_add.sin_port,
        unikix_sock_add.sin_port,
	(unikix_addr >> 24) & 0xFF,
	(unikix_addr >> 16) & 0xFF,
	(unikix_addr >>  8) & 0xFF,
	(unikix_addr) & 0xFF,
        unikix_sock_add.sin_addr,
        unikix_sock_add.sin_addr,
        unikix_sock_add.sin_addr.s_addr,
        unikix_sock_add.sin_addr.s_addr,
	unikix_sock_add.sin_port,
        sizeof(struct sockaddr),
        sizeof(struct sockaddr)   
      );*/

   if (connect(c_vplus_socket, (struct sockaddr *)&unikix_sock_add, sizeof(struct sockaddr)) < 0 )
   {
        close(c_vplus_socket);
	return(FUNCTION_FAILED);
   }

   /* Initial send to invoke transaction */
   if (send_message(c_vplus_socket, vplus_mxg_buf, VPLUS_RESP_LEN) == FUNCTION_FAILED)
   {
      close(c_vplus_socket);
      return (FUNCTION_FAILED);
   }
   wwrite_to_log("TRANSID", "Wrote following message",vplus_mxg_buf,VPLUS_RESP_LEN,PRINT_TEXT);
   if ( ind_first == TRUE )
   {
      comm_timeout = FALSE;
      signal(SIGALRM,no_vplus_connection);
      alarm(3);
      if ((length=recv(c_vplus_socket, vplus_mxg_buf, VPLUS_RESP_LEN, MSG_WAITALL)) != VPLUS_RESP_LEN)
      {
         alarm(0);
         if ( chk_moni(55) == TRUE )
         {
           fprintf(stderr,"<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
           fputs("!!!!!!!        No VPLUS Response   !!!!!!!\n",stderr);
           fputs("!!!!!!!        No VPLUS Response   !!!!!!!\n",out_err_file);
         }
         close(c_vplus_socket);
         return (FUNCTION_FAILED);
      }
      alarm(0);
     ind_no_reg=TRUE;
     if ((chk_reg_file = fopen(chk_region_name,"r")))
     {
        if ( fgets (reg_line,18,chk_reg_file) != NULL )
        {
          reg_line[17]='\0';
          if ( strcmp(reg_id,reg_line) == 0)
             ind_no_reg=FALSE;
        }
        fclose(chk_reg_file);
     }
     if ( ind_no_reg == TRUE )
     {
       if ( chk_moni(62) == TRUE )
       {
         region_name = getenv("PROJECT_ROOT");
         puts("\n --------------------------------------------------------------------------");
         printf("| Did not received region information from Vion Plus Application\n");
         printf("|                              OR                              \n");
         if ( region_name != NULL )
           printf("| Program is connecting to a socket in a region other than %s\n",region_name);
         else
           printf("| Program is connecting to a socket in a different region \n");
         puts(" --------------------------------------------------------------------------\n");
        }
        close(c_vplus_socket);
        errno=0;/*to not display any other error messages*/
        return (FUNCTION_FAILED);
     }
     if ( strncmp(&vplus_mxg_buf[23],"CONNECT-TYPE = 06",17) != 0 )
     {
       if (type_network == VISA )
       {
       if ( chk_moni(63) == TRUE )
       {
         puts("\n ------------------------------------------------------------------------------");
         puts("|          FAS is not configured for TCP/IP; run OFSP to change this           |");
         puts(" ------------------------------------------------------------------------------\n");
       }
       close(c_vplus_socket);
       errno=0;/*to not display any other error messages*/
       return (FUNCTION_FAILED);
       }
     }
      wwrite_to_log("Vplus Connect(1)", "Read following data",vplus_mxg_buf,length,PRINT_TEXT);
   }
   else
   {
      /* To void to many forked process for this, Vplus will be checked every 5 seconds*/
      if ( return_time > ( cnt_sec_chk_vplus + WAIT_TO_CHK_VPLUS ) || cnt_sec_chk_vplus == FIRST_COUNT )
      {
         cnt_sec_chk_vplus=return_time;
         if ( ( pid = fork() ) == 0 )/*if connection to VPLUS is not first the
                                 fork so there is no wait for vplus response*/
         {
            int moni_pipe;

            if ( debug_opt != TRUE )
               signal(SIGINT, SIG_IGN);
            comm_timeout = FALSE;
            signal(SIGALRM,no_vplus_connection);
            alarm(15);
            if ((length=recv(c_vplus_socket, vplus_mxg_buf, VPLUS_RESP_LEN, MSG_WAITALL)) != VPLUS_RESP_LEN)
            {
               alarm(0);
               if ( comm_timeout == TRUE )
                  errno=0;
   /******************************************************************************/
   /* since chk_moni will not work because of the fork,  EEXIST and EINTR will be test to redisplay the error (this is because first time errno seems not to be EEXIST or EINTR */
   /******************************************************************************/
               if ( errno != EEXIST && errno != EINTR )
               {
                  print_socket_error(NOT_USED,"No VPLUS Response while initializing a CICS transaction");
                  sprintf(line_rep_num,"echo ERR-OR-MSG > v+_comm.in.count.%c",connect_letter);
                  system(line_rep_num);
                  puts("\n\n");
                  printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
                  printf("!!! WARNING: IT SEEMS THAT FAS IS NOT RESPONDING TO %s REQUESTS  !!!!\n",remote_name);
               }
/******************************************************************************/
/* writing to pipe will indicate to inbound process to do next connection to v+ as if were the first*/
/******************************************************************************/
               if ((moni_pipe = open_int_proc_pipe(moni_i_pipe_name,NO_CLEAR)) != FUNCTION_FAILED)
               {
                  write(moni_pipe,"recon_v+",8);
                  close(moni_pipe);
               }
               exit_chk_vplus(UNSUCCESSFULLY);/*This exit won't make parent re-stablish connection, since exit is to a fork in this function; however writing to pipe should make inbound process to exit if error persists*/
            }
            alarm(0);
            wwrite_to_log("Vplus Connect", "Read following data",vplus_mxg_buf,length,PRINT_TEXT);
            exit_chk_vplus(SUCCESSFULLY);
         }
         else
         {
             if ( pid == FUNCTION_FAILED )
             {
                fprintf(stderr,"?");
             }
         }
         check_childs();
      }
   }
   return (c_vplus_socket);
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 *  connect_to_remote
 **********************************************************************/
connect_to_remote()
{
   struct sockaddr_in remote_sock_add;

   int c_socket;


   c_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
   if (c_socket < 0)
   {
       if ( chk_moni(56) == TRUE )
          print_socket_error(NOT_USED,"remote socket");
       return(FUNCTION_FAILED);
   }

   memset(&remote_sock_add, 0, sizeof(struct sockaddr_in));
   remote_sock_add.sin_family=AF_INET;
   remote_sock_add.sin_addr.s_addr = remote_addr;
   remote_sock_add.sin_port=htons(atoi(remote_port));
   remote_port_num=remote_sock_add.sin_port;
   /*printf("sock:family %d(%x) port %d(%x) host addr [%ld] %d.%d.%d.%d(%d(%x) + (%d(%x))) : socket port %d len struc=%d(%x)\n",
        remote_sock_add.sin_family,
        remote_sock_add.sin_family,
        remote_sock_add.sin_port,
        remote_sock_add.sin_port,
        remote_addr,
	(remote_addr >> 24) & 0xFF,
	(remote_addr >> 16) & 0xFF,
	(remote_addr >>  8) & 0xFF,
	(remote_addr) & 0xFF,
        remote_sock_add.sin_addr,
        remote_sock_add.sin_addr,
        remote_sock_add.sin_addr.s_addr,
        remote_sock_add.sin_addr.s_addr,
	remote_sock_add.sin_port,
        sizeof(struct sockaddr),
        sizeof(struct sockaddr)   
      );*/

   if (connect(c_socket, (struct sockaddr *)&remote_sock_add, sizeof(struct sockaddr)) < 0 )
   {
        close(c_socket);
	return(FUNCTION_FAILED);
   }

   /* Initial send to invoke transaction */
   return (c_socket);
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 * clear_pipe
 **********************************************************************/

clear_pipe (int cfd)
{
   int r_stat;
   char empty_buff[168];

   while ( (r_stat=read(cfd,empty_buff,168)) > 0);
   if ( r_stat == FUNCTION_FAILED)
   {
       if ( chk_moni(57) == TRUE )
          puts("Can not empty pipe");
       return (FUNCTION_FAILED);
   }
 return(FUNCTION_OK_0);
}


/**********************************************************************
 * open_int_proc_queue  
 **********************************************************************/
int open_int_proc_queue(key_t key)
{
   int pfd;

   if ((pfd=msgget(key, 0666 | IPC_CREAT )) == FUNCTION_FAILED )
      return (FUNCTION_FAILED);

   if (( msgctl(pfd,IPC_RMID,NULL) == FUNCTION_FAILED ))
   {
       if ( chk_moni(58) == TRUE )
          print_error("clearing interprocess queue");
       exit(UNSUCCESSFULLY);
   }
   if ((pfd=msgget(key, 0666 | IPC_CREAT )) == FUNCTION_FAILED )
      return (FUNCTION_FAILED);
   
   return(pfd);
   
}

/**********************************************************************/
/**********************************************************************/


/**********************************************************************
 * open_int_proc_pipe  
 **********************************************************************/
int open_int_proc_pipe(char *pname,int ind_clear)
{
   int pfd;

   if ((mkfifo(pname, S_IFIFO | 0770)) == FUNCTION_FAILED && errno != EEXIST )
      return (FUNCTION_FAILED);
   
   if ( (pfd = open(pname, O_RDWR | O_NDELAY )) == FUNCTION_FAILED )
	 return (FUNCTION_FAILED);
   
   if ( ind_clear == DO_CLEAR )
   {
      if (clear_pipe(pfd) == FUNCTION_FAILED )
         return (FUNCTION_FAILED);
   }
   return(pfd);
   
}

/**********************************************************************
 *  no_exit
 **********************************************************************/
void no_exit()
{
  exit_timeout = TRUE;
}
/**********************************************************************/
/**********************************************************************/
/**********************************************************************
 * wait_for_all_childs
 * 
 *      *****    THIS FUNCTION IS USED DURING SHUTDOWN    *****
 *
 * This function will wait for the inbound process(es) to finish. The 
 * trans_stat[x][PID_FOR_PORT] varible will indicated if the SIGCHLD signal is
 * been captured for an inbound process (see sig_inbound_exited() ).
 * If after WAIT_TO_SHUTDOWN seconds this is not detected then a message
 * will be displayed indicating that an inbound process may be still 
 * running.
 **********************************************************************/
void wait_for_all_childs()
{

   int count;
   int childs_still_running;
   int num_retries=0;
   int printed_first = FALSE;


   signal(SIGALRM, no_exit);
   alarm(WAIT_TO_SHUTDOWN);
   do
   {
      childs_still_running = FALSE;
      for ( count=0 ; count<NUMBER_OF_SESSIONS ; count++)
      {
         if ( trans_stat[count][PID_FOR_PORT] != 0 )
           childs_still_running = TRUE;
      }
      if ( exit_timeout == TRUE )
      {
        num_retries++;
        write(shutdown_pipe,"Shutdown",8);    
        signal(SIGALRM, no_exit);
        exit_timeout = FALSE;
        alarm(WAIT_TO_SHUTDOWN);
      }
      if ( num_retries == 3 )
      {
        for ( count=0 ; count<NUMBER_OF_SESSIONS ; count++)
        {
           if ( trans_stat[count][PID_FOR_PORT] != 0 )
           {
             if ( printed_first == FALSE )
             {
               puts("The following session(s) could still be running:");
               fputs("The following session(s) could still be running:\n",out_err_file);
               printed_first = TRUE;
             }
             printf("Process %d\n",trans_stat[count][PID_FOR_PORT]);
             fprintf(out_err_file,"Process %d\n",trans_stat[count][PID_FOR_PORT]);
           }
        }
        break;
      }
   }while(childs_still_running == TRUE);
   alarm(0);

   return;
}
/**********************************************************************/

/**********************************************************************/
/**********************************************************************
 * get_h_errno()
 * 
 **********************************************************************/
char *get_h_errno(int h_errno_code)
{
   switch ( h_errno_code )
   {
     case HOST_NOT_FOUND:
       return("Answer Host not found");
     case TRY_AGAIN:
       return("Host not found in /etc/hosts file, or SERVERFAIL");
     case NO_RECOVERY:
       return("Non recoverable error");/* e.g. FORMERR, REFUSED, NOTIMP*/
     case NO_DATA:
       return("Valid name, no data record of requested type");
     default:
       return("Unknow error");
   }
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************
 * Chk_moni()  /*last number used Mar 10 1999 was 64
 * 
 **********************************************************************/
chk_moni(int msg_num)
{
   
   int count, rmon_num;
   int write_rmon_flg = FALSE;
   int saved_errno;/*to save errno so this routine does not overwrite it value for error handling*/
   int val_to_chk, chk_minute;
   char *rmon_line[10];
   char *rep_date;

   saved_errno=errno;
   if ( type_session == INBOUND )
     sprintf(line_rep_num,"echo ERR-OR-MSG > v+_comm.in.count.%c",connect_letter);
   else
     sprintf(line_rep_num,"echo ERR-OR-MSG > v+_comm.out.count.%c",connect_letter);
   system(line_rep_num);
   if ( debug_opt == TRUE )
   {
     printf("\n\nDBG: [%d]: ",msg_num);
     errno=saved_errno;
     return(TRUE);
   }
   moni_cleared=FALSE;
   for ( count=0 ; count<MAX_MONI_MSG ; count++ )
   {
     if ( moni_msg_table[count][0] == msg_num )
     {
        ++moni_msg_table[count][1];
        if ( moni_msg_table[count][1] == 1 )
        {
            printf("\n<<<   Previous Error or Message [%d] is repeating   >>>",msg_num);
        }
        else
        {
          rep_date=str_date();
          if ( MONI_REDISPLAY_MINUTE < 0 )
          {
             val_to_chk = MONI_REDISPLAY_MINUTE * -1;
             if ( val_to_chk > 9 )
               val_to_chk = 9;
             if ( minutes_of_time != 0)
               chk_minute = minutes_of_time % 10;
             else
               chk_minute = 0;
          }
          else
          {
            val_to_chk = MONI_REDISPLAY_MINUTE;
            if ( val_to_chk > 59 )
               val_to_chk = 59;
            chk_minute = minutes_of_time;
          }
          if ( chk_minute == val_to_chk )
          {
             if ( moni_msg_table[count][2] == 0 )
             {
                printf("\n<<<  %s(pid=%d):  >>>\n",rep_date,getpid());
                printf("<<<   Error or Message [%d] has been repeated %d times>>>",msg_num,moni_msg_table[count][1]);
                moni_msg_table[count][2]=1;
              }
          }
          else
          {
                moni_msg_table[count][2]=0;
          }
        }
        errno=saved_errno;
        return(FALSE);
     }
   }

   for ( count=MAX_MONI_MSG - 1 ; count >= 0 ; count-- )
   {
      moni_msg_table[count][0]=moni_msg_table[count -1][0] ;
      moni_msg_table[count][1]=moni_msg_table[count -1][1] ;
      moni_msg_table[count][2]=moni_msg_table[count -1][2] ;
   }
   moni_msg_table[0][0]=msg_num;
   moni_msg_table[0][1]=0;
   moni_msg_table[0][2]=0;
   
   printf("\n\n[%d]: ",msg_num);
   errno=saved_errno;
   return(TRUE);
}
/**********************************************************************/
/**********************************************************************/

/**********************************************************************/
/**********************************************************************/
/**********************************************************************
 * load_moni()
 * 
 **********************************************************************/
void load_moni( int rmoni_socket)
{
   int count=0;
   int num_returned;
   int moni_number;
   int moni_ind;
   int rep_moni_ind;
   char moni_line[10];

      do
      {
          num_returned = recv(rmoni_socket, moni_line, 5,MSG_DONTWAIT );
          if ( num_returned == FUNCTION_FAILED || num_returned != 5)
             break;
          moni_number=atoi(moni_line);
          if ( moni_number == 9999 )
          {
              clear_moni(V_NOT_CONNECTED);
              break;
          }
          num_returned = recv(rmoni_socket, moni_line, 9,MSG_DONTWAIT );
          if ( num_returned == FUNCTION_FAILED || num_returned != 9)
             break;
          moni_ind=atoi(moni_line);
          num_returned = recv(rmoni_socket, moni_line, 2,MSG_DONTWAIT );
          if ( num_returned == FUNCTION_FAILED || num_returned != 2)
             break;
          rep_moni_ind=atoi(moni_line);
          if ( count < MAX_MONI_MSG && moni_number != 0 )
          {
            moni_msg_table[count][0]=moni_number;
            moni_msg_table[count][1]=moni_ind;
            moni_msg_table[count][2]=rep_moni_ind;
          }
          count++;
      }while (num_returned != FUNCTION_FAILED && num_returned != 0);

}
/**********************************************************************/
/**********************************************************************/


/**********************************************************************/
/**********************************************************************/
/**********************************************************************
 * clear_moni(int type_c)
 * 
 **********************************************************************/
clear_moni(int type_c)
{
   
   int count;

   moni_cleared=TRUE;
   if ( type_c == O_V_CONNECTED )
   {
      puts("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
      fprintf(stderr,"\n\n<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
      printf("!!!! Connected to Vplus (port=%d)  !!!!\n",unix_out_port);
      sprintf(line_rep_num,"echo JUST-CONNECTED > v+_comm.out.count.%c",connect_letter);
      system(line_rep_num);
   }
   for ( count=0 ; count<MAX_MONI_MSG ; count++ )
   {
      moni_msg_table[count][0]=0;
      moni_msg_table[count][1]=0;
      moni_msg_table[count][2]=0;
   }
}
/**********************************************************************/
/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/* Main function processing for socket program                        */
/*                                                                    */
/**********************************************************************/
int main(int argc, char *argv[])
{
   extern char *optarg;
   extern int optind;

   struct hostent *remote_host, *gethostbyname();
   struct timeval *connect_wait;
   struct timeval connect_val_add;
   struct MSGBUF r_buff;

   char err_heading[257];
   char *region_name;  /*Pointer set by getenv()*/

   char get_connect_type[3];
   int internal_socket=NOT_ESTABLISHED;
   int int_socket_count=NOT_ESTABLISHED;
   int no_outbound_running = TRUE;
   int listen_remote_socket;
   int in_vplus_socket;
   int remote_socket;
   int in_stat;
   int rn_length;
   int count;
   int trans_inx=0;
   int moni_pair[2];
   int spair[2];
   int spair2[2];
#if 0
   int type_connection =  SERVER_CONNECTION;
#endif
   int type_connection =  CLIENT_CONNECTION;

   fd_set read_set;
   int scnt;

   pid_t pid;
   int stat;
   int errflg = 3;

   int num_param = 0;
   int length;
   int len_out_name;
   int com_switch;
   int msg_queue_key;

   char out_port_number[PORT_LEN + 1];
   char *option_value = NULL; /* Will point to option value(string)*/

   void sig_inbound_exited(int);
   void sig_outbound_exited(int);
   void sig_inbound_int(int);
   void sig_main_int(int);

   signal(SIGINT, SIG_IGN);
   setbuf(stdout,NULL);
   signal(SIGPIPE, SIG_IGN);
   signal(SIGCHLD, sig_inbound_exited);


   unikix_port = getenv("FASKIXPORT");
   if ( unikix_port == NULL )
   {
       puts ("Missing FASKIXPORT variable\n");
       exit_init(UNSUCCESSFULLY);
   }
   server_port = atoi(unikix_port) + 1;/*If SERVER_CONNECTION*/

 
   start_time=time(0L);

   for ( count=0 ; count<MAX_MONI_MSG ; count++)
   {
     moni_msg_table[count][0]=0;
     moni_msg_table[count][1]=0;
     moni_msg_table[count][2]=0;
   }
   region_name = getenv("PROJECT_ROOT");
   if ( region_name == NULL )
   {
      puts("\n ------------------------------------------------------------------------------");
      puts("| ERROR: This program must be started from a Vision Plus region($PROJECT_ROOT) |");
      puts(" ------------------------------------------------------------------------------\n");
      exit_init(UNSUCCESSFULLY);
   }

   while((com_switch = getopt(argc, argv, "h:p:r:d:t:")) != EOF)
   {
        switch(com_switch)
        {

           case 'r':      /* remote port number*/
               num_param++;
               if (optarg != NULL) 
                  errflg--;
               remote_port = optarg;
               num_remote_port = atoi(remote_port);
               break;

           case 'h':    /* remote server name in /etc/hosts*/
               num_param++;
               if (optarg != NULL) errflg--;
               remote_name = optarg;
               rn_length=strlen(remote_name);
/******************************************************************************
e.g. Command arg has onx1_#01: the _#[0-9]0-9] will indicate that type need to 
be checked. Since get_connect_type is 01(two digits after _#), then connect_type
will be set to ONX_SWITCH and remote_name to onx1 (which needs to be define in
/etc/hosts
******************************************************************************/
               if ( strncmp(&remote_name[rn_length - 4],"_#",2) == 0 && 
                    remote_name[rn_length - 2] >= '0' &&
                    remote_name[rn_length - 2] <= '9' &&
                    remote_name[rn_length - 1] >= '0' &&
                    remote_name[rn_length - 1] <= '9' 
                  )
               {
                   strcpy(get_connect_type,&remote_name[rn_length - 2]);
                   remote_name[rn_length - 4]='\0';
                   if (strcmp(get_connect_type,"01") == 0) /*ONX Switch for Bancared */
                   {
                      puts("CONNECTION TYPE IS ONX");
                      connect_type=ONX_SWITCH;
                      type_connection =  SERVER_CONNECTION;
                      time_to_check_activity=6; /*ONX sends echos every 5 minutes*/
                   }
                   if (strcmp(get_connect_type,"02") == 0) 
                   {
                      puts("CONNECTION TYPE IS HYPERCOM AS CLIENTE");
                      connect_type=HYPERCOM;
                      type_connection =  SERVER_CONNECTION;
                   }
                   if (strcmp(get_connect_type,"03") == 0) 
                   {
                      puts("CONNECTION TYPE IS HYPERCOM AS SERVER");
                      connect_type=HYPERCOM;
                      type_connection =  CLIENT_CONNECTION;
                   }
               }
               if((remote_host = gethostbyname(remote_name)) == NULL) {
                   fprintf(stderr, "Invalid Host Name \"%s\": %s\n",optarg,get_h_errno(h_errno));
                   exit_init(UNSUCCESSFULLY);
               } else {
                   memcpy(&remote_addr, *(remote_host->h_addr_list), 4);
               }
               break;
           case 'd':  /* option used for debugging purposes.*/
                      /* If set to 'y', the a hex dump of messages      */
                      /* and all error massages will                    */
                      /* be written to the err file*/
               if (optarg != NULL)
               {
                  option_value = optarg;
                  if ( option_value[0] == 'y' || option_value[0] == 'Y' )
                     debug_opt = TRUE;
               }
               break;

           case 't':      /* Incomming Trans_ID*/
               num_param++;
               if (optarg != NULL) errflg--;
               trans_id = optarg;
               if ( strlen(trans_id) != 4 )
               {
                 printf ("%s: Length of Incoming Transaction ID is not 4\n",argv[0]);
                 exit_init(UNSUCCESSFULLY);
               }
               if ( strncmp(trans_id,"OFJ",3) != 0 && strncmp(trans_id,"OFMI",4) != 0 )
               {
                 printf ("%s: %4.4s Is an invalid Transaction ID \n",argv[0],trans_id);
                 exit_init(UNSUCCESSFULLY);
               }
               if ( strncmp(trans_id,"OFMI",4) == 0 )
               {
                 type_network=MASTER_CARD;
                 connect_letter='M'; 
               }
               if ( strncmp(trans_id,"OFJ",3) == 0 )
               {
                 type_network=VISA;
                 connect_letter=trans_id[3];
                 if ( connect_letter < 'A' || connect_letter > 'L' )
                 {
                    printf("Connection %c for VISA is not valid",connect_letter);
                    exit_init(UNSUCCESSFULLY);
                 }
               }
               break;


           default:       /* the rest are errors */
               errflg++;
               break;
        }
   }
   if ( type_network == MASTER_CARD && connect_type != HYPERCOM) /*MCVTSTES*/
   { /*MCVTSTES*/
      if ( debug_opt != TRUE  ) /*MCVTSTES*/
      { /*MCVTSTES*/
         puts("DBGTODEL: Currently this program can be tested with the VTS2000 if using the \"-d y\" option, and if connection_type is not HYPERCOM (e.g. remote_name param= hyp1_#02"); /*DBGTODEL*/
      } /*MCVTSTES*/
      else /*MCVTSTES*/
      { /*MCVTSTES*/
        printf ("MCVTSTES: Running MasterCard(no HYPERCOM) under debug; right now this mode in only good with a VTS2000 simulator\n");  /*MCVTSTES*/
      } /*MCVTSTES*/
      getchar();getchar(); /*MCVTSTES*/
   } /*MCVTSTES*/
   if (num_param != 3 || errflg) {
       usage(argv[0],type_connection);
   }
  
 
#if 0
~~~~~~~~~~~~~~~~~~~~~~~~~   DEL ~~~~~~~~~~~~~~~~~~~~~~~~
   if ( remote_port == NULL && type_connection ==  SERVER_CONNECTION )
        num_param++;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#endif
   if ( debug_opt == TRUE )
   {
      puts("******    MAIN PROCESS RUNNING    ******");
      signal(SIGINT, SIG_DFL);
   }
   kix_sys = getenv("KIXSYS");
   if ( kix_sys == NULL )
   {
       puts ("Missing KIXSYS variable\n");
       exit_init(UNSUCCESSFULLY);
   }
   if(chdir (kix_sys) ==  FUNCTION_FAILED )
   {
       printf("Can not chdir to %s \n",kix_sys);
       perror("Error:");
       exit_init(UNSUCCESSFULLY);
   }
   if(chdir ("fascom") ==  FUNCTION_FAILED )
   {
       printf("Can not chdir to %s/fascom - run OFSP and retry - \n",kix_sys);
       perror("Error:");
       exit_init(UNSUCCESSFULLY);
   }
   run_f_name[13]=connect_letter;
   creat(run_f_name, 0666 );

   in_err_name[15]=connect_letter;
   out_err_name[16]=connect_letter;
   shut_pipe_name[13]=connect_letter;
   moni_i_pipe_name[13]=connect_letter;
   moni_o_pipe_name[13]=connect_letter;
   moni_i_ind_name[17]=connect_letter;
   moni_o_ind_name[17]=connect_letter;
   chk_region_name[17]=connect_letter;
   out_port_f_name[13]=connect_letter;
   capt_name[13]=connect_letter;


   if (!(out_err_file = fopen(in_err_name,"w")))
   {
      fputs("Err file = stderr",stderr);
      out_err_file=stderr;
   }
   else
   {
      setbuf(out_err_file,NULL);
   }
   fprintf(out_err_file,"%s\n",str_date());
   fprintf(out_err_file,"trans_id=%s letter=%c port=%s \n",trans_id,connect_letter,out_port_f_name);
   printf("%s: 1999-07-20-00\n",argv[0]);
   printf("Inbound Err file is %s \n",in_err_name);
   fprintf(out_err_file,"File opened by PID %d\n",getpid());

   for ( trans_inx = 0; trans_inx < NUMBER_OF_SESSIONS ; trans_inx++ )
   {
       trans_stat[trans_inx][PORT_STATUS] = FREE__PORT;
       trans_stat[trans_inx][PID_FOR_PORT] = 0;
       trans_stat[trans_inx][PORT_NUMBER] = 0;
   }
   trans_inx=0;

#if 0
*******************************************************************************
* I may need to use a message queue instead of the named pipe. This is because
* the named pipe could even be read from a shell UNIX command. Using the message
* queue will make the shutdown process more reliable.
*******************************************************************************
#endif
   if ((shutdown_pipe = open_int_proc_pipe(shut_pipe_name,DO_CLEAR)) == FUNCTION_FAILED)
   {
       print_error("opening interprocess pipe(shutdown)");
       exit_main(UNSUCCESSFULLY);
   }
   if ( multiple_connection == TRUE )
   {
      if ((out_port_fd = open_int_proc_queue(PORT_QUEUE_KEY)) == FUNCTION_FAILED)
      {
          print_error("opening interprocess port queue");
          exit_main(UNSUCCESSFULLY);
      }
   }

   if (shutdown_pipe >= maxfd)
      maxfd = shutdown_pipe + 1;
   if ( type_connection == SERVER_CONNECTION )
   {
      if ((listen_remote_socket = start_listen(server_port, remote_name)) == FUNCTION_FAILED)
      {
       
          sprintf(err_heading,"Error while waiting for connection from %s (listen function)",remote_name);
          print_socket_error(NOT_USED,err_heading);
          exit_main(UNSUCCESSFULLY);
      }
      if (listen_remote_socket >= maxfd)
          maxfd = listen_remote_socket + 1;
   }


#if 0
*******************************************************************************
* If CLIENT_CONNECTION, 
* connect_wait is used to indicate the amount of time to wait before displaying
* a message indicating that connection is being attempted.
* This waiting will be done through the select() function; thus a shutdown could
* be caught at any time during this wait. 
* connect_wait is set initially to 1 second, then it will be set to the value of
* SEC_TO_WAIT_TO_CONNECT
* 
* If SERVER_CONECTION, then connect_wait is set to NULL to wait for ever for
* the remote to try to connect.
*******************************************************************************
#endif
   if ( type_connection == CLIENT_CONNECTION )
   {
      connect_wait = &connect_val_add;
      connect_wait->tv_sec = 1L;
      connect_wait->tv_usec = 0L;
   }
   else
   {
      connect_wait=NULL;
   }
   fprintf(out_err_file,"Comm-Driver process started (TRANSID=%s unikix port=%s)\n",trans_id,unikix_port);
   printf("Unikix port=%s  ",unikix_port);
   if ( type_connection == SERVER_CONNECTION )
     printf("Server port=%d\n",server_port);
   else
     puts("");


   for(; ; ) /* loop 'connection' */
   {

      FD_ZERO(&read_set);
      FD_SET(shutdown_pipe, &read_set);

      if ( type_connection == CLIENT_CONNECTION )
      {
         if ( connection_failure == TRUE || limit_num_of_connection == FALSE  )
         {
            if ( connection_failure == TRUE )
            {
                connect_wait->tv_sec = (long)SEC_TO_WAIT_TO_CONNECT;
              if ( chk_moni(1) == TRUE )
                printf("...........  Will try connection in %d seconds  ............        \n\n",SEC_TO_WAIT_TO_CONNECT);
            }
         }
      }
      else
      {
         if ( chk_moni(2) == TRUE )
            printf("\n\n        ------------   Listening for connection(pid=%d) -----------\n\n",getpid());
         length = 0;
         FD_SET(listen_remote_socket, &read_set);/*if a server program*/
      }
   
#if 0
*******************************************************************************
* If CLIENT_CONNECTION, then this select is just a connect_wait for re-tries
* when we are connecting to the remote. In this case wait is just 1 second
* when first trying to connect, and then the value of SEC_TO_WAIT_TO_CONNECT
* when re-trying.
*
* If SERVER_CONECTION, then this select is to wait for the remote signal when
* trying to connect to us, the we detect this signal the we go and accept
* connection.
*******************************************************************************
#endif
      if ((scnt = select(maxfd, &read_set, NULL, NULL, connect_wait)) == FUNCTION_FAILED)
      {
            if ( child_exited == TRUE )
            {
               child_exited = FALSE;
               continue;
            }
            if ( type_connection == CLIENT_CONNECTION )
               sprintf(err_heading,"Error during wait before trying connection with %s (select function)",remote_name);
            else
               sprintf(err_heading,"Error while waiting for connection from %s (select function)",remote_name);
            if ( chk_moni(3) == TRUE )
              print_error(err_heading);
            continue;
      }
      /*********************************************************************/
      /* set connection_failure = TRUE                                     */
      /* This value will be reset to FALSE if a good connection is made    */
      /*********************************************************************/
      connection_failure = TRUE;

      if ( type_connection == CLIENT_CONNECTION )
         connect_wait->tv_sec = 1L;
   
      if ((scnt > 0) && FD_ISSET(shutdown_pipe, &read_set))
      {
         puts("Shutting down...");
         fputs("Shutdown requested\n",out_err_file);
         wait_for_all_childs();
         break; /*shutdown detected*/
      }

      if (type_connection == CLIENT_CONNECTION || ((scnt > 0) && FD_ISSET(listen_remote_socket, &read_set)))
      {
         if ( scnt > 0 )
            scnt --;
         if ( type_connection == CLIENT_CONNECTION )
         {
            if ( chk_moni(4) == TRUE )
            {
              printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
              printf("   ------------   Connecting to %s (port=%s ) -----------\n\n",remote_name,remote_port,getpid());
            }
            if ((remote_socket = connect_to_remote()) == FUNCTION_FAILED )
            {
                
                sprintf(err_heading,"!!!!  Connection with %s|port-%s failed  !!!!",remote_name,remote_port);
                if ( chk_moni(5) == TRUE )
                   print_socket_error(NOT_USED,err_heading);
                continue;
            }
            else
            {
                if ( chk_moni(6) == TRUE )
                {
                  printf("<<<  %s(pid=%d):  >>>\n",str_date(),getpid());
                  printf("*****  Connected to %s  ******\n",remote_name);
                  if ( debug_opt == TRUE )
                  {
                     fprintf(out_err_file,"\n\n%s(pid=%d)\n",str_date(),getpid());
                     fprintf(out_err_file,"*****  Connected to %s  ******\n",remote_name);
                  }
                }
            }
         }
         else
         {
            if ((remote_socket = accept(listen_remote_socket, NULL, &length)) == FUNCTION_FAILED)
   
            {
               sprintf(err_heading,"Error while accepting connection from %s (accept function)",remote_name);
               if ( chk_moni(7) == TRUE )
                  print_socket_error(NOT_USED,err_heading);
               continue;
            }
         }

         if ( multiple_connection == FALSE )
         {
            trans_inx = 0;
            unix_out_port = num_remote_port + ((trans_inx + 1) * 10) + num_out_try;
         }
         else
         {
            free_port(CHECK_PENDING);
            for ( ; trans_inx < NUMBER_OF_SESSIONS ; trans_inx++ )
               if ( trans_stat[trans_inx][PORT_STATUS] == FREE__PORT )
                  break;
            if ( trans_inx == NUMBER_OF_SESSIONS )
            {
               if ( limit_num_of_connection == FALSE )
               {
                  if ( chk_moni(8) == TRUE )
                     puts("All Vplus ports are busy at this time...\n");
               }
               connection_failure = FALSE;
               trans_inx = 0;
               continue;
            }
            unix_out_port = num_remote_port + 1 + trans_inx;
         }

         len_out_name=strlen(out_err_name);
         sprintf(out_port_number,"%0*d",PORT_LEN,unix_out_port);
         sprintf(&out_err_name[len_out_name - 5],"%05d",unix_out_port);
         out_err_name[len_out_name]='\0';
         if ( multiple_connection == TRUE )
         {
            strncpy(r_buff.buf,out_port_number,PORT_LEN);
            r_buff.mtype=1;
            if (msgsnd(out_port_fd,&r_buff,PORT_LEN,IPC_NOWAIT) != FUNCTION_OK_0)
            {
               if ( chk_moni(9) == TRUE )
                  perror("writting to out_port_fd");
               continue;
            }
         }

/******************************************************************************/
/** clear outbound err file, so outbound process can open it in append mode **/
/******************************************************************************/
         if ((cout_err_file = fopen(out_err_name,"w")))
            fclose(cout_err_file);   

         trans_stat[trans_inx][PORT_STATUS] = USED_PORT;
         trans_stat[trans_inx][PORT_NUMBER] = unix_out_port;
#if 0
*******************************************************************************
* socketpair used to keep track of moni_msg_table
*******************************************************************************
#endif
                  if (socketpair(AF_UNIX, SOCK_STREAM, 0, moni_pair) == FUNCTION_FAILED)
                  {
                      if ( chk_moni(16) == TRUE )
                         print_socket_error(NOT_USED,"socketpair() failed");
                      exit_main(UNSUCCESSFULLY);
                  }
                  moni_socket=moni_pair[0];
         if ( ( pid = fork() ) == 0 )/*inbound process(es)*/
         {
            sprintf(line_rep_num,"echo JUST-CONNECTED > v+_comm.in.count.%c",connect_letter);
            system(line_rep_num);
            if ( debug_opt != TRUE )
               signal(SIGINT, SIG_IGN);
            signal(SIGCHLD, SIG_DFL);/* not to do what parent is doing*/
            if ( debug_opt == TRUE )
               puts("******    INBOUND PROCESS RUNNING    ******");
            close(moni_pair[0]);
            moni_socket=moni_pair[1];
    /*************************************************************************/
    /******  signal(SIGCHLD, sig_outbound_exited);                      ******/
    /******  processes for this are done when return from inbound_session ****/
    /******  is = SESSION_SUSPENDED                                    *******/
    /*************************************************************************/
            if ( type_connection == SERVER_CONNECTION )
               close(listen_remote_socket);

#if 0
******************************************************************************
* By creating out_port_file at this place, we can monitor when a non-multiple
* type of connection is being initiated. The file will be create empty 
* indicating that there is only a connection with the remote at this time,
* and the port number will be
* written to it by the connection with remote and FAS is establihed.
* The file will be re-cleared with the creat function after the outbound
* process exits indicating that conection to FAS is lost, and it will be
* unlinked after the inbound process  exits indicating that there is no 
* connection to remote or FAS.                            
*
* This out_port_file will be read by FAS outgoing requests to connect to the
* outbound port.
*
* The cheking of a multiple connection will be done by looking the port
* message queue.
*****************************************************************************
#endif
 
            if ( multiple_connection == FALSE )
            {
               if ( (out_port_file = creat(out_port_f_name, 0666 )) == FUNCTION_FAILED )
               {
                   print_error("creating out port iterprocess file ");/*no chk_moni since shutdown*/
                   write(shutdown_pipe,"Shutdown",8);
                   exit_inbound(UNSUCCESSFULLY,0);
               }
            }

            for( ; ; ) /* loop: 'start FAS tran'  for next incomming message*/
            {
               if ((in_vplus_socket = connect_to_vplus(trans_id)) == FUNCTION_FAILED )
               {
                   /* 02/18/99 if in_vplus_socket was opened, then connect_to_vplus closed it*/
                   if ( errno != 0 && comm_timeout != TRUE )
                   {
                      if ( chk_moni(10) == TRUE )
                         print_socket_error(CON_VPLUS,"Connection with VPLUS failed... ");
                   }
                   else
                   {
                      if ( errno != 0 && chk_moni(17) == TRUE )
                      {
                         fprintf(stderr,"Make sure that UNIKIX has created a sockeck to listen on port %s\n",unikix_port);
                         fprintf(stderr,"\nNow Disconnecting from %s... ",remote_name);
                      }
                   }
                   exit_inbound(10,moni_socket);
               }
               if (in_vplus_socket == EXIT_PROGRAM )
               {
                   write(shutdown_pipe,"Shutdown",8);    
                   exit_inbound(UNSUCCESSFULLY,0);
               }
               ind_first = FALSE;
               if (in_vplus_socket >= maxfd)
                  maxfd = in_vplus_socket + 1;
               if ( no_outbound_running == TRUE )
               {
                  no_outbound_running = FALSE;
#if 0
*******************************************************************************
* socketpair will indicate when either the inbound or outbound process exits,
* so the other one will exit too.
* internal socket between inbound and outbound also servers as a moni_socket
*******************************************************************************
#endif
                  if (socketpair(AF_UNIX, SOCK_STREAM, 0, spair) == FUNCTION_FAILED)
                  {
                      if ( chk_moni(11) == TRUE )
                         print_socket_error(NOT_USED,"socketpair() failed");
                      exit_inbound(11,moni_socket);
                  }
                  internal_socket=spair[0];
                  if (internal_socket >= maxfd)
                     maxfd = internal_socket +1;
                  if (socketpair(AF_UNIX, SOCK_STREAM, 0, spair2) == FUNCTION_FAILED)
                  {
                      if ( chk_moni(12) == TRUE )
                         print_socket_error(NOT_USED,"socketpair() failed");
                      exit_inbound(12,moni_socket);
                  }
                  int_socket_count=spair2[0];
                  if ( ( pid = fork() ) == 0 )/*outbound process*/
                  {
               
                     if ( debug_opt != TRUE )
                        signal(SIGINT, SIG_IGN);
                     type_session=OUTBOUND;
/****************************   OUTBOUND PROCESS   ****************************/
                     if ( debug_opt == TRUE )
                         puts("******    OUTBOUND PROCESS RUNNING    ******");
                     if ( out_err_file != stderr )
                         close(out_err_file);
                     close(spair[0]);
                     close(spair2[0]);
                     close(in_vplus_socket);
                     internal_socket=spair[1];
                     moni_socket=spair[1];/*moni_socket here is same internal socket; which is used for monitor exchange from outbound to inbound as oppose to moni_socket/moni_pair used to exchange from inbound to main process*/
                     int_socket_count=spair2[1];
                     if (internal_socket >= maxfd)
                         maxfd = internal_socket +1;
                     if ( multiple_connection == FALSE )
                     {
                        if ( (write(out_port_file,out_port_number,PORT_LEN)) == FUNCTION_FAILED )
                        {
                            if ( chk_moni(13) == TRUE )
                                print_error("writing to out port iterprocess file ");
                            exit_outbound(13,moni_socket);
                        }
                     }
                     if ((outbound_session(remote_socket, internal_socket, int_socket_count)) == FUNCTION_FAILED)
                     {
                       
#if 0
--------------  remarked -------------
                        if ( chk_moni(14) == TRUE )
                           printf("\nOutbound process error. check %s file...\n","out_err_name");
------------------------------
#endif
                        exit_outbound(14,moni_socket);
                     }
     
                      /* SESSION_SUSPENDED */
                      close(remote_socket);
                      if ( multiple_connection == FALSE )
                         close(out_port_file);
                      close(internal_socket);
                                  /*This will cause parent(if in session loop*/
			          /*to select the internal_socket, and then  */
			          /*go to main loop to try to accept other   */
			          /*connection.                              */
                      exit_outbound(SUCCESSFULLY,0);/*outbound exits, NOT inbound*/
/*****************************************************************************/
   
                  }/*end outbound fork*/
                  else
                  {
                     if ( pid == FUNCTION_FAILED )
                     {
                        if ( chk_moni(15) == TRUE )
                           print_error("Outbound forking");
                        exit_inbound(15,moni_socket);
                     }
                  }
                  check_childs();

/*******************    Continue with INBOUND PROCESS    **********************/
                  close(spair[1]);
                  close(spair2[1]);
               }
               if ((in_stat = inbound_session(remote_socket, in_vplus_socket, internal_socket,int_socket_count, shutdown_pipe)) == SHUTDOWN_REQUESTED )
               {
                   puts("\nShutdown requested: Waiting for outbound process to exit");
                   sleep(WAIT_TO_SHUTDOWN);/* To wait for and outbound process to response to an inbound message*/
                   close(internal_socket); 
                             /* If child still running, This will cause it*/
                             /* to select internal socket and then exit.  */
                   waitpid (pid, &stat, 0); /*Wait for child to finish before next accept*/
                   write(shutdown_pipe,"Shutdown",8);    
                   exit_inbound(SUCCESSFULLY,0);
               }

               if ( in_stat != FUNCTION_OK_0 )
               {
                   sleep(2);/*wait for moni_info from outbound process*/
                   load_moni(internal_socket);/*NOTE that monitor exchange between outbound and inbound is done through internal_socket; However in the outbound process value of internal_socket is moved to moni_socket var, so that common exit routing uses the same name. Only this functions actually uses internal_socket name, because in here we are in the inbound process and not the outbound*/
                   close(internal_socket); 
                             /* If child still running, This will cause it*/
                             /* to select internal socket and then exit.  */
                   waitpid (pid, &stat, 0); /*Wait for child to finish before next accept*/
                   if ( in_stat == SESSION_SUSPENDED )
                   {
                      if ( debug_opt == TRUE )
                      {
                          puts("\nOutbound process exited...\n");
                          fprintf(out_err_file,"Outbound process %d terminated\n",pid);
                      }
                      if ( multiple_connection == FALSE )
                         creat(out_port_f_name, 0666 );/*clear file*/
                   }
                   if ( out_err_file != stderr )
                     close(out_err_file);
                   close(remote_socket);

                   close(in_vplus_socket);
                   close(shutdown_pipe);
                   if ( multiple_connection == FALSE )
                       close(out_port_file);
                   if ( type_connection == SERVER_CONNECTION )
                      close(listen_remote_socket);
                   exit_inbound(UNSUCCESSFULLY,moni_socket);
            
               }
               close(in_vplus_socket);
            }/* end loop 'start FAS tran' */
        }/*end fork inbound process(es)*/
        else
        {
            if ( pid == FUNCTION_FAILED )
            {
               if ( chk_moni(18) == TRUE )
                  print_error("connection forking");
               close(remote_socket);
               continue;
            }
        }
        check_childs();
        close(moni_pair[1]);
#if 0
*******************************************************************************
* trans_stat[][PID_FOR_PORT] to keep track of the inbound process id
*******************************************************************************
#endif 
        trans_stat[trans_inx][PID_FOR_PORT] = pid;
        ind_first = TRUE;
        if ( multiple_connection == FALSE )
        {
          waitpid (pid, &stat, 0); /*Wait for child to finish before trying to  reconnect*/
          if ( num_out_try < 9 )
            num_out_try++;
          else
            num_out_try=0;
          sleep(3);
        }
        close(remote_socket);
        load_moni(moni_socket);
        close(moni_socket);
     }/*end FD_ISSET(listen_remote_socket...*/
     /*if ( type_connection == CLIENT_CONNECTION )
        connection_failure = FALSE;*/



   }  /* end loop 'connection' */

   close(internal_socket); /* If child still running, This will cause it*/
                           /* to select internal socket and exit.       */
   close(remote_socket);
   close(in_vplus_socket);
   close(shutdown_pipe);
   if ( type_connection == SERVER_CONNECTION )
      close(listen_remote_socket);
   if ( out_err_file != stderr )
      close(out_err_file);
   exit_main(SUCCESSFULLY);
}  /* end of main function processing                                   */
